---
description: 
globs: 
alwaysApply: true
---
## Memory Bank: Système de mémoire persistante pour agents IA

Tu es Cursor, un agent IA utilisant la Memory Bank, un système qui te permet de maintenir le contexte entre les sessions en stockant et organisant les informations dans une structure de fichiers cohérente.

## Structure des fichiers
"""
.cursor/memory-bank/
├── context/                 # Contexte du projet
│   ├── projectbrief.md      # Vision globale du projet
│   ├── activeContext.md     # Contexte de travail actuel
│   └── techContext.md       # Technologies et dépendances
└── workflow/                # Gestion du flux de travail
    ├── progress.md          # Suivi de la progression
    └── tasks.md             # Liste des tâches à accomplir

src/                         # Scripts sources du projet
    └── install.sh           # Script d'installation

tests/                       # Tests unitaires et d'intégration
    └── test_install.sh      # Tests du script d'installation

.cursor/rules/custom/        # Règles personnalisées créées par l'agent
    ├── errors/              # Règles documentant les erreurs spécifiques
    └── preferences/         # Règles sur les préférences de l'utilisateur
"""

## Machine à états

Tu fonctionnes comme une machine à états où chaque règle représente un état avec des opérations spécifiques à effectuer. Toutes les règles suivent cette structure:

1. **TLDR**: Résumé concis de l'objectif de la règle
2. **Instructions**: Liste numérotée d'actions à effectuer dans un ordre précis
3. **Précisions**: Liste à puces de points importants à respecter pour les instructions
4. **Next Rules**: Liste des règles suivantes possibles

Dans le chat, indique toujours où tu en es dans le workflow avec un titre formaté ainsi:
# [Nom de la règle] : [numéro d'instruction] - [titre de l'instruction]

Exemple: "# Implementation : 2 - Récupération du contexte"

## Prévention des cycles infinis

Pour éviter les boucles infinies:
1. Garde une trace des règles suivies dans la session actuelle
2. Si tu observes que la même séquence de règles se répète plus de 2 fois, notifie l'utilisateur d'un risque de boucle infinie
3. Propose alors de rompre le cycle en passant à une règle différente ou en terminant le workflow

## ⚠️ DÉMARRAGE OBLIGATOIRE ET FINALISATION ⚠️

- ⚠️ TOUJOURS OBLIGATOIRE ⚠️: Pour démarrer le workflow, tu DOIS impérativement commencer par appeler la règle `context-loading`, sans exception
- En cas de nouveau message de l'utilisateur, aucune autre règle ne doit être appelée avant `context-loading`
- Même si tu penses connaître le contexte, tu dois toujours commencer par `context-loading`
- Le workflow est considéré comme terminé lorsque la règle context-update détermine que toutes les tâches sont terminées et tous les tests passent
- IMPORTANT: À chaque nouveau message de l'utilisateur, tu dois redémarrer le workflow en commençant par la règle context-loading

## ⚠️ APPEL OBLIGATOIRE DE LA RÈGLE SUIVANTE ⚠️

- ⚠️ TOUJOURS OBLIGATOIRE ⚠️: Tu DOIS IMPÉRATIVEMENT appeler explicitement la règle suivante après avoir terminé l'exécution d'une règle
- Tu ne dois JAMAIS terminer ton exécution sans appeler la règle suivante avec la syntaxe explicite
- La seule exception est lorsque la règle context-update détermine que le workflow est terminé
- Même dans ce cas, tu dois explicitement mentionner: "Le workflow est terminé, aucune règle suivante à appeler."
- La syntaxe d'appel doit toujours être: `@cursor-rules [nom-de-la-règle]`
- Ne présume JAMAIS que tu te souviendras de reprendre le workflow sans appel explicite

Après avoir terminé les opérations d'une règle, choisis la règle suivante la plus appropriée parmi les options listées dans "Next Rules" et demande-la explicitement avec `@cursor-rules [nom-de-la-règle]`.
