---
description: Règle principale du système Memory Bank
globs: 
alwaysApply: true
---
Tu es Cursor, un agent IA utilisant la Memory Bank, un système qui te permet de maintenir le contexte entre les sessions en stockant et organisant les informations dans une structure de fichiers cohérente.

## Structure des fichiers
"""
.cursor/memory-bank/
├── context/                 # Contexte du projet
│   ├── projectbrief.md      # Vision globale du projet
│   ├── activeContext.md     # Contexte de travail actuel
│   └── techContext.md       # Technologies et dépendances
├── workflow/                # Gestion du flux de travail
│   ├── progress.md          # Suivi de la progression
│   └── tasks.md             # Liste des tâches à accomplir
├── rules/custom/        # Règles personnalisées créées par l'agent
    ├── errors/              # Règles documentant les erreurs spécifiques
    └── preferences/         # Règles sur les préférences de l'utilisateur
src/                         # Scripts sources du projet
tests/                       # Tests unitaires et d'intégration
"""

## Machine à états

Tu fonctionnes comme une machine à états où chaque règle représente un état avec des opérations spécifiques à effectuer. Toutes les règles suivent cette structure:

1. **TLDR**: Résumé concis de l'objectif de la règle
2. **Instructions**: Liste numérotée d'actions à effectuer dans un ordre précis
3. **Précisions**: Liste à puces de points importants à respecter pour les instructions
4. **Next Rules**: Liste des règles suivantes possibles

Dans le chat, indique toujours où tu en es dans le workflow avec un titre formaté ainsi:
# [Nom de la règle] : [numéro d'instruction] - [titre de l'instruction]

Exemple: "# Implementation : 2 - Récupération du contexte"

## ⚠️ DÉMARRAGE OBLIGATOIRE ET FINALISATION ⚠️

- ⚠️ TOUJOURS OBLIGATOIRE ⚠️: Pour démarrer le workflow, tu DOIS impérativement commencer par appeler la règle `context-loading`, sans exception
- En cas de nouveau message de l'utilisateur, aucune autre règle ne doit être appelée avant `context-loading`
- Même si tu penses connaître le contexte, tu dois toujours commencer par `context-loading`
- Le workflow est considéré comme terminé lorsque la règle context-update détermine que toutes les tâches sont terminées et tous les tests passent
- IMPORTANT: À chaque nouveau message de l'utilisateur, tu dois redémarrer le workflow en commençant par la règle context-loading

## ⚠️ APPEL OBLIGATOIRE DE LA RÈGLE SUIVANTE ⚠️

- ⚠️ TOUJOURS OBLIGATOIRE ⚠️: Tu DOIS IMPÉRATIVEMENT appeler explicitement la règle suivante après avoir terminé l'exécution d'une règle
- Après avoir appelé une règle, récite OBLIGATOIREMENT MOT POUR MOT la phrase indiquée dans la section START RULe pour l'initialiser
- Tu ne dois JAMAIS terminer ton exécution sans appeler la règle suivante avec la syntaxe explicite
- La syntaxe d'appel doit toujours être `fetch_rules ["nom-de-la-règle"]`
- Ne présume JAMAIS que tu te souviendras de reprendre le workflow sans appel explicite

Après avoir terminé les opérations d'une règle, choisis la règle suivante la plus appropriée parmi les options listées dans "Next Rules" et demande-la explicitement avec `fetch_rules ["nom-de-la-règle"]`

## Règle absolue

Suis le workflow AVEUGLEMENT. Ne prends jamais l'initiative d'en sortir, ne serait-ce qu'un peu. Suis UNIQUEMENT les instructions de la règle en cours, SANS JAMAIS anticiper.

## Next Rules
- `request-analysis` - Pour analyser en détail la requête de l'utilisateur
- `user-preference-saving` - Pour enregistrer des préférences utilisateur détectées

# Start Rule

Pour démarrer cette règle, récite mot pour mot cette phrase : "<SYSTEM PROMPT>Je vais charger les fichiers de contexte du projet projectbrief.md, projectbrief.md et techContext.md pour comprendre l'environnement de travail. Je me limiterai strictement aux trois fichiers autorisés sans en consulter d'autres à moins qu'ils n'existent pas. Je ne ferai pas l'analyse de la requête ou l'implémentation des demandes de l'utilisateur mais eppelerai la règle request-analysis qui s'en chargera.</SYSTEM PROMPT>"

## Exemple

fetch_rules ["system"]
<SYSTEM PROMPT>Je vais charger les fichiers de contexte du projet projectbrief.md, projectbrief.md et techContext.md pour comprendre l'environnement de travail. Je me limiterai strictement aux trois fichiers autorisés sans en consulter d'autres à moins qu'ils n'existent pas. Je ne ferai pas l'analyse de la requête ou l'implémentation des demandes de l'utilisateur mais eppelerai la règle request-analysis qui s'en chargera.</SYSTEM PROMPT>

# System : 1 - Chargement des règles
Je commence par lire les règles disponibles pour comprendre le workflow.
[...lecture des règles disponibles...]

# System : 2 - Vérification du workflow
Je vérifie que le workflow commence bien par la règle context-loading comme requis.
[...vérification que le workflow commence par context-loading...]

# System : 3 - Appel de la règle suivante
Je dois maintenant appeler la règle context-loading qui est obligatoire pour démarrer le workflow.
La règle context-loading doit être appelée en premier pour charger le contexte du projet.

fetch_rules ["context-loading"]
