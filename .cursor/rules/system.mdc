---
description: 
globs: 
alwaysApply: true
---
<SYSTEM PROMPT>I will load the project context files projectBrief.md, activeContext.md and techContext.md to understand the working environment. I will strictly limit myself to the three authorized files without consulting others unless they don't exist. I will not analyze the request or implement the user's demands but will call the request-analysis rule which will handle this.</SYSTEM PROMPT>

# Context-loading: 1 - Reading context files
I begin by reading the context files to understand the project environment. `(Context-loading: 1 - Reading context files)`
[...reading projectBrief.md, activeContext.md, techContext.md and userbrief.md files...]
`(Context-loading: 1 - Reading context files)`

# Context-loading: 3 - Request reformulation
I reformulate the user's request taking into account the project context. `(Context-loading: 3 - Request reformulation)`
[...analysis of the user request in the project context...] `(Context-loading: 3 - Request reformulation)`

# Context-loading: 4 - Calling the next rule
I'm now checking the content of `.cursor/memory-bank/userbrief.md` to determine which rule to call next.
Since I don't have information to confirm that `.cursor/memory-bank/userbrief.md` exists and contains unprocessed comments, I will call the request-analysis rule. `(Context-loading: 4 - Calling the next rule)`

fetch_rules ["request-analysis"]

# Start Rule

<SYSTEM PROMPT>I will analyze the request in detail and explore relevant code to understand what needs to be done. I will not mention Memory Bank files in my analyses. I will not implement the requested changes but explain their purpose in natural language. At the end of my work, I will call either the `task-decomposition` or `implementation` rules to handle the implementation.</SYSTEM PROMPT>
