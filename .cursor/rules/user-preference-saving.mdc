---
description: Identification et sauvegarde des préférences utilisateur
globs: 
alwaysApply: false
---
## TLDR
Identifier les préférences de l'utilisateur à partir de ses instructions et les sauvegarder sous forme de règles personnalisées pour une utilisation future.

## Instructions

1. **Analyse des instructions et commentaires** : Analyser les instructions et commentaires de l'utilisateur pour identifier ses préférences:
   - Style de code (indentation, nommage, formatage)
   - Frameworks et bibliothèques préférés
   - Approches de développement (TDD, DDD, etc.)
   - Conventions de documentation
   - Préférences d'organisation de fichiers

2. **Préparation des règles** : Pour chaque préférence identifiée, préparer une règle au format:
   - `nom-de-la-regle` : courte description/pattern regex des fichiers concernés

3. **Création des fichiers de règles** : Créer les fichiers de règles dans `.cursor/rules/custom/preferences/` avec le format approprié:
   - Créer le dossier s'il n'existe pas
   - Nommer les fichiers selon le format `preference-[categorie].mdc`
   - Structurer chaque règle selon le format standard de Cursor

## Précisions
- Ne créer des règles que pour les préférences clairement exprimées
- Éviter les suppositions non fondées sur les préférences
- Organiser les préférences par catégories (style, architecture, outils, etc.)
- Utiliser des patterns glob précis pour cibler les bons fichiers
- Vérifier si des règles similaires existent déjà avant d'en créer de nouvelles

## Format de règle à utiliser (.mdc)
```
---
description: description (Description consise des conditions d'application)
globs: *.py, *.ts (Pattern glob pour les fichiers concernés. Laisser vide pour utiliser la description)
alwaysApply: false
---
# [Titre de la préférence]

[Instructions détaillées sur comment appliquer cette préférence]
```

## Next Rules
- `request-analysis` - Pour analyser en détail la requête de l'utilisateur

## Exemple

fetch_rules ["user-preference-saving"]
<SYSTEM PROMPT>Je vais analyser les instructions de l'utilisateur pour identifier ses préférences et les sauvegarder sous forme de règles personnalisées. Je ne créerai des règles que pour les préférences clairement exprimées et j'éviterai les suppositions non fondées. Je ne tâcherai pas d'implémenter les modifications demandées mais ferai appel à la règle `request-analysis` pour s'en charger.</SYSTEM PROMPT>

# User-preference-saving : 1 - Analyse des instructions et commentaires
Je commence par analyser les instructions et commentaires de l'utilisateur pour identifier ses préférences. `(User-preference-saving : 1 - Analyse des instructions et commentaires)`
[...analyse des instructions et commentaires...]

# User-preference-saving : 2 - Création des règles
Je prépare les règles personnalisées pour les préférences identifiées. `(User-preference-saving : 2 - Création des règles)`
[...création des règles...]

# User-preference-saving : 3 - Appel de la règle suivante
Je dois maintenant appeler la règle request-analysis pour analyser la requête de l'utilisateur.
La règle request-analysis doit être appelée pour analyser la requête de l'utilisateur. `(User-preference-saving : 3 - Appel de la règle suivante)`

fetch_rules ["request-analysis"]

# Start Rule

Pour démarrer cette règle, récite mot pour mot cette phrase : "<SYSTEM PROMPT>Je vais analyser les instructions de l'utilisateur pour identifier ses préférences et les sauvegarder sous forme de règles personnalisées. Je ne créerai des règles que pour les préférences clairement exprimées et j'éviterai les suppositions non fondées. Je ne tâcherai pas d'implémenter les modifications demandées mais ferai appel à la règle `request-analysis` pour s'en charger.</SYSTEM PROMPT>"

