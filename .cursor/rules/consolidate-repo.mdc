---
description: Rule to consolidate the repository, manage userbrief.md, and maintain a clean project structure
globs: 
alwaysApply: false
---
## TLDR
Checks for new user requests using the MemoryBank MCP server, marks them as 'in_progress', and triggers their decomposition. Also verifies memory file integrity.

## Instructions

1.  **Check for User Requests**: Use the `read-userbrief` MCP tool to check for new or pending user requests.
    *   Call `mcp_MemoryBank_read-userbrief`.
    *   This tool abstracts the direct reading of `userbrief.json`.

2.  **Process New Request (if any)**: If a 'new' request is found, mark it as 'in_progress'.
    *   Analyze the response from the previous step.
    *   IF a `current_request` exists AND its `status` is `'new'`:
        *   Call `mcp_MemoryBank_update-userbrief` with `action: 'mark_in_progress'` and the `id` of the request.
        *   This marks the task for the next step without directly modifying any files.
    *   Preferences (`📌`) are not handled by this version of the rule. All new items are treated as tasks.

3. **Integrity verification**: Control of memory files:
   - Use the MCP command execution tool via Git Bash to list all markdown files: `mcp_MyMCP_execute_command(command = "\"C:\\Program Files\\Git\\bin\\bash.exe\" -c \"find . -type f -name '*.md'\"")`
   - Analyze results to identify duplicates or misplaced files in `memory-bank` directories.

4. **Direct Cleanup**: Directly resolve integrity issues identified in step 3.
   - If duplicates found:
     - Merge content of duplicate files into the main corresponding file (using file edit tools).
     - Delete duplicates after merging using the MCP command execution tool via Git Bash (e.g., `mcp_MyMCP_execute_command(command = "\"C:\\Program Files\\Git\\bin\\bash.exe\" -c \"rm <duplicate_file_path>\""")`).
   - If misplaced files found:
     - Move misplaced files to their correct location within the `memory-bank` structure (using `mcp_MyMCP_execute_command` with `mv`).
   - If other temporary/unnecessary files identified:
     - Delete them using the MCP command execution tool via Git Bash (`rm`).

5. **MCP Terminal Cleanup**: Clean up finished terminal processes used in this rule.
   - Call `mcp_get_terminal_status` to check the status of running/finished processes.
   - For each process with a final status (e.g., 'Success', 'Failure'), call `mcp_stop_terminal_command` with its `pid` to release resources.

6. **Evaluation of user requests & Next Rule**: Decide next workflow step based on the initial check.
   - Re-call `mcp_MemoryBank_read-userbrief` to get the latest status (which may have been updated in step 2).
   - IF the tool returns a `current_request` with status `'in_progress'` or `'new'`:
     - Extract the `content` of that request.
     - Formulate this as the user request to be analyzed.
     - Call `task-decomposition` rule to process this specific request.
   - ELSE (no active request found):
     - Call `context-update` rule to continue the general workflow.

## Specifics
- This rule no longer interacts with `.cursor/memory-bank/userbrief.md`. All userbrief operations are handled via `mcp_MemoryBank_*` tools.
- It focuses on processing one user request at a time.
- The `task-decomposition` rule is responsible for processing items marked `'in_progress'`.
- Integrity verification and cleanup steps (3, 4, 5) remain important.

## Repository Structure (for reference)
```
.cursor/memory-bank/  
├── context/                 # Project context  
│   ├── projectBrief.md      # Project global vision  
│   ├── activeContext.md     # Current work context  
│   └── techContext.md       # Technologies and dependencies  
├── workflow/                # Workflow management  
│   ├── tasks.md             # List of tasks to accomplish
│   └── tests.md             # Test results tracking
src/                         # Project source scripts  
tests/                       # Unit and integration tests  
```

## userbrief.md: New Format Definition

The `.cursor/memory-bank/userbrief.md` file no longer uses H1 section titles (e.g., `# User Input`, `# Processing`). It is a flat list of items, each starting with an emoji indicating its status or type. This rule (`consolidate-repo`) is primarily responsible for processing new user inputs (🆕) and categorizing them.

**Emoji Legend & Handling by `consolidate-repo`:**
*   `🆕 - [User's original request or idea]`
    *   Represents raw user input. Users should ideally prefix new requests with `🆕 -` or just `- ` (which this rule will treat as 🆕).
    *   This rule identifies these items.
    *   If it's a task-like request, this rule changes 🆕 to ⏳.
    *   If it's a preference/directive, this rule changes 🆕 to 📌.
*   `⏳ - [Task identified, awaiting decomposition by task-decomposition rule]`
    *   This rule changes 🆕 to ⏳ for actionable tasks.
    *   The `task-decomposition` rule will later process these ⏳ items.
*   `📌 - [User preference or long-term directive to be retained]`
    *   This rule changes 🆕 to 📌 for preferences.
    *   These items are generally preserved unless explicitly changed by the user.
*   `🗄️ - [Request archived by task-decomposition after being added to tasks.md]`
    *   This rule does NOT create or directly manage 🗄️ items. They are an outcome of the `task-decomposition` rule.

**Key Principles (from former `userbrief-template.mdc`):**
*   **Persistence**: The `userbrief.md` file should generally not be emptied by the agent; only the user should clear its content.
*   **Status Updates**: When changing status, only the leading emoji should be modified by the agent, not the content of the request/preference itself unless explicitly instructed.
*   **Conciseness**: The file should be kept as concise as possible without losing information.
*   **User Input**: Users can add new items by prefixing with `🆕 - ` or just `- `.


## Next Rules

- `task-decomposition` - If a `🆕` item was converted to `⏳` (or an existing `⏳` item is found), to analyze this specific task.
- `context-update` - If no `🆕` items were processed into `⏳` tasks (e.g., only preferences found, or no new input).

## Example

# Consolidate-repo: 1 - Process `userbrief.md` Items
I begin by reading `.cursor/memory-bank/userbrief.md` to find new user inputs (starting with `🆕 - ` or `- `). **(Consolidate-repo: 1 - Process `userbrief.md` Items)**
[...reading `userbrief.md`... Assume it contains:
- `- Add a new feature X.
- Make the UI blue.
`]
I found the first new item: `- Add a new feature X.` This appears to be a task. I will change its prefix to `⏳ - `.
[...editing `userbrief.md` to become:
`⏳ - Add a new feature X.
- Make the UI blue.
` ...]
**(Consolidate-repo: 1 - Process `userbrief.md` Items)**

# Consolidate-repo: 2 - Integrity verification
(Assuming no integrity issues for this example path)
I'm now verifying the integrity of memory files. **(Consolidate-repo: 2 - Integrity verification)**
[...MCP find command...]
No integrity issues found.
**(Consolidate-repo: 2 - Integrity verification)**

# Consolidate-repo: 3 - Direct Cleanup
No cleanup needed. **(Consolidate-repo: 3 - Direct Cleanup)**

# Consolidate-repo: 4 - MCP Terminal Cleanup
No terminal commands were used that require cleanup in this path. **(Consolidate-repo: 4 - MCP Terminal Cleanup)**

# Consolidate-repo: 5 - Evaluation of user requests & Next Rule
I re-read `userbrief.md`. It now contains `⏳ - Add a new feature X.`. **(Consolidate-repo: 5 - Evaluation of user requests & Next Rule)**
I found a task marked `⏳`. I will formulate "Add a new feature X" as the request and call `task-decomposition`.
**(Consolidate-repo: 5 - Evaluation of user requests & Next Rule)**

[...Calling `task-decomposition` rule...]

[...] (The workflow must continue uninterrupted: even if the example stops here, the agent must IMPERATIVELY continue in reality: it MUST call and execute the following rule, then the next, etc., without ever stopping -> It is completely autonomous.)  