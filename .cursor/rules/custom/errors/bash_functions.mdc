---
description: Common issues with bash function organization and usage
globs: *.mdc
alwaysApply: false
---
# Erreurs courantes avec les fonctions Bash

## Probl√®me: Accolades manquantes ou mal plac√©es
- ‚ùå **Incorrect**:
  ```bash
  if ! some_command; then
      echo "Error"
      return 1
  }  # Accolade fermante sans ouvrante
  ```
- ‚úÖ **Correct**:
  ```bash
  if ! some_command; then
      echo "Error"
      return 1
  fi  # Utiliser fi pour fermer un if
  ```
- üìù **Explication**: En Bash, les blocs if sont ferm√©s avec `fi`, pas avec des accolades. Les accolades sont utilis√©es pour les fonctions et les blocs de code.

## Probl√®me: Retour au r√©pertoire pr√©c√©dent manquant
- ‚ùå **Incorrect**:
  ```bash
  cd "$some_dir"
  do_something
  # Pas de retour au r√©pertoire pr√©c√©dent
  ```
- ‚úÖ **Correct**:
  ```bash
  local current_dir="$(pwd)"
  cd "$some_dir" || return 1
  do_something
  cd "$current_dir"  # Retour au r√©pertoire pr√©c√©dent
  ```
- üìù **Explication**: Toujours sauvegarder le r√©pertoire courant et y retourner apr√®s avoir chang√© de r√©pertoire, surtout dans les fonctions de test.

## Probl√®me: Gestion des erreurs de cd
- ‚ùå **Incorrect**:
  ```bash
  cd "$some_dir"
  # Pas de v√©rification d'erreur
  ```
- ‚úÖ **Correct**:
  ```bash
  cd "$some_dir" || {
      log_error "Failed to change to directory $some_dir"
      return 1
  }
  ```
- üìù **Explication**: Toujours v√©rifier le succ√®s des commandes cd et g√©rer les erreurs appropri√©es.

## Probl√®me: Ordre de d√©finition des fonctions
- ‚ùå **Incorrect**: Appeler une fonction avant sa d√©finition
  ```bash
  main_function  # Erreur: fonction non d√©finie
  
  main_function() {
    echo "Hello"
  }
  ```
- ‚úÖ **Correct**: D√©finir les fonctions avant leur utilisation
  ```bash
  main_function() {
    echo "Hello"
  }
  
  main_function  # OK: fonction d√©j√† d√©finie
  ```
- üìù **Explication**: En Bash, les fonctions doivent √™tre d√©finies avant d'√™tre utilis√©es. Organisez votre code en d√©finissant d'abord toutes les fonctions, puis en les appelant.

## Probl√®me: Tests en mode local vs production
- ‚ùå **Incorrect**: Utiliser des URLs absolues dans les tests
  ```bash
  test_download() {
    download_file "https://example.com/file" "$TEST_DIR/file"
  }
  ```
- ‚úÖ **Correct**: Utiliser des fichiers locaux en mode test
  ```bash
  test_download() {
    if [[ "$TEST_MODE" == "1" ]]; then
      # Utiliser des fichiers locaux pour les tests
      cp "$TEST_DIR/fixtures/file" "$TEST_DIR/file"
    else
      # Utiliser les URLs r√©elles en production
      download_file "https://example.com/file" "$TEST_DIR/file"
    fi
  }
  ```
- üìù **Explication**: Les tests ne devraient pas d√©pendre de ressources externes. Utilisez des fichiers locaux en mode test pour garantir la fiabilit√© et la rapidit√© des tests.

## Probl√®me: Chemins relatifs dans les tests
- ‚ùå **Incorrect**: Utiliser des chemins relatifs au script de test
  ```bash
  setup() {
    cp "../dist/file.txt" "$TEST_DIR/file.txt"  # Erreur: chemin relatif au script
  }
  ```
- ‚úÖ **Correct**: Utiliser des chemins relatifs au r√©pertoire d'ex√©cution
  ```bash
  setup() {
    SCRIPT_DIR="$(dirname "$0")"
    PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
    cp "$PROJECT_ROOT/dist/file.txt" "$TEST_DIR/file.txt"  # OK: chemin absolu
  }
  ```
- üìù **Explication**: Les chemins relatifs dans les tests peuvent √©chouer selon le r√©pertoire d'ex√©cution. Utilisez des chemins absolus ou relatifs au r√©pertoire racine du projet.

## Problem: Missing Test Variables
- ‚ùå **Incorrect**: Using undefined variables in tests
  ```bash
  test_download() {
      download_file "$DOWNLOAD_URL" "$dest"  # Error: DOWNLOAD_URL not defined
  }
  ```
- ‚úÖ **Correct**: Define all required variables before tests
  ```bash
  # Test setup
  DOWNLOAD_URL="https://example.com/file"
  TEST_DIR="/tmp/test"
  
  test_download() {
      download_file "$DOWNLOAD_URL" "$TEST_DIR/file"
  }
  ```
- üìù **Explication**: Always define test variables in the setup section, before any test cases that use them.

## Download Functions and URL Handling

### Common Issues:

1. **Raw GitHub URLs for Private Repos**
   - Problem: Using raw.githubusercontent.com URLs for private repositories fails
   - Solution: Use local test files or public release URLs instead
   - Example:
     ```bash
     # Bad
     URL="https://raw.githubusercontent.com/private/repo/main/file"
     
     # Good
     URL="https://github.com/org/repo/releases/download/v1.0/file"
     # Or for tests
     URL="file://$TEST_DIR/test-file"
     ```

2. **URL Construction**
   - Problem: Incomplete URLs missing filenames or using wrong separators
   - Solution: Always construct full URLs with proper path joining
   - Example:
     ```bash
     # Bad
     DOWNLOAD_URL="$BASE_URL"
     
     # Good
     DOWNLOAD_URL="${BASE_URL}/${ARCHIVE_NAME}"
     ```

3. **Test vs Production URLs**
   - Problem: Mixing test and production URLs without proper fallbacks
   - Solution: Use environment variables with clear defaults
   - Example:
     ```bash
     # Bad
     URL="${TEST_URL:-https://prod.example.com}"
     
     # Good
     if [[ -n "${TEST_MODE:-}" ]]; then
       URL="$TEST_URL"
     else
       URL="$PROD_URL"
     fi
     ```

### Best Practices:

1. Always validate URLs before download attempts
2. Use proper URL encoding for special characters
3. Handle both HTTP and local file URLs
4. Provide clear error messages for URL-related failures
5. Test with both local and remote URLs

## Probl√®me: Interf√©rence entre tests cons√©cutifs
- ‚ùå **Incorrect**: Ex√©cuter des tests sans nettoyer compl√®tement l'environnement entre chaque test
  ```bash
  test_first() {
    mkdir -p "$TEST_DIR"
    # Test qui cr√©e des fichiers...
  }
  
  test_second() {
    # Test qui v√©rifie l'absence de certains fichiers
    if ls -d "$TEST_DIR/*.bak" &>/dev/null; then
      log_error "Files found when they shouldn't be"
    fi
  }
  ```
- ‚úÖ **Correct**: Nettoyer compl√®tement l'environnement ou utiliser des r√©pertoires distincts pour chaque test
  ```bash
  test_first() {
    local test_specific_dir="$TEST_DIR/test1"
    mkdir -p "$test_specific_dir"
    # Test qui cr√©e des fichiers...
  }
  
  test_second() {
    local test_specific_dir="$TEST_DIR/test2"
    mkdir -p "$test_specific_dir"
    # Test qui v√©rifie l'absence de certains fichiers
    if ls -d "$test_specific_dir/*.bak" &>/dev/null; then
      log_error "Files found when they shouldn't be"
    fi
  }
  ```

## Probl√®me: Cr√©ation implicite de backups
- ‚ùå **Incorrect**: Cr√©er des backups dans plusieurs fonctions sans contr√¥le centralis√©
  ```bash
  install_rules() {
    # Cette fonction cr√©e des backups sans respecter l'option DO_BACKUP
    cp -r "$source" "$dest.bak"  # Cr√©e toujours un backup
  }
  ```
- ‚úÖ **Correct**: Centraliser la logique de backup dans une seule fonction
  ```bash
  make_backup() {
    if [[ -n "${DO_BACKUP:-}" ]]; then
      cp -r "$source" "$dest.bak"
    fi
  }
  
  install_rules() {
    # Utilise la fonction centralis√©e
    make_backup "$source" "$dest"
  }
  ``` 