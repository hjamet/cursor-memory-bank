---  
description: Appelle cette règle pour structurer la requête en tâches concrètes et mesurables  
globs:   
alwaysApply: false  
---  

## TLDR  
Décomposer la requête utilisateur en tâches concrètes et les organiser dans tasks.md par sections logiques numérotées.  

## Instructions  

1. **Analyse des tâches existantes** : Lire le fichier `.cursor/memory-bank/workflow/tasks.md` s'il existe  

2. **Suppression des tâches terminées** : Éliminer les tâches terminées sans lien avec le travail actuel  

3. **Intégration des nouvelles tâches** : Structurer les tâches dans tasks.md  
   - Créer 3-4 sections de très haut niveau maximum (ex: "Préparation", "Développement")  
   - Numéroter sections par ordre de résolution (1., 2., 3.)  
   - Sous-numéroter les tâches (1.1, 1.2, 2.1, 2.2)  
   - Chaque tâche doit inclure :  
     * Titre concis  
     * Description complète  
     * Fichiers/composants impactés  
     * Dépendances  
     * Critères de validation  
   - Prioriser selon importance, dépendances, impact et complexité  

4. **Appel de la règle suivante** : Appeler obligatoirement `implementation`  

## Précisions  
- Regrouper les tâches similaires, même si apparemment différentes  
- Privilégier descriptions détaillées plutôt que multiplication de sections  
- Utiliser sections génériques pouvant accueillir différents types de tâches  
- Minimiser les dépendances entre sections/tâches  
- Le format du fichier tasks.md est défini dans la règle d'édition tasks-md  

## Next Rules  
- `implementation` - Pour commencer l'implémentation des tâches  

## Exemple  

fetch_rules ["task-decomposition"]  
<SYSTEM PROMPT>Je vais décomposer la requête en tâches concrètes, supprimer les tâches terminées non pertinentes et organiser le tout en sections logiques numérotées. Je ne tenterai pas d'appliquer ces tâches mais ferai appel à la règle `implementation` pour s'en charger.</SYSTEM PROMPT>  

# Task-decomposition : 1 - Analyse des tâches existantes  
Je commence par lire le fichier tasks.md pour comprendre l'état actuel des tâches. `(Task-decomposition : 1 - Analyse des tâches existantes)`  
[...lecture du fichier tasks.md...]  
`(Task-decomposition : 1 - Analyse des tâches existantes)`  

# Task-decomposition : 2 - Suppression des tâches terminées  
Je supprime les tâches terminées qui ne sont plus pertinentes pour le travail en cours. `(Task-decomposition : 2 - Suppression des tâches terminées)`  
[...suppression des tâches obsolètes...]  
`(Task-decomposition : 2 - Suppression des tâches terminées)`  

# Task-decomposition : 3 - Intégration des nouvelles tâches  
Je décompose la requête en tâches concrètes et les organise en sections de haut niveau. `(Task-decomposition : 3 - Intégration des nouvelles tâches)`  
[...organisation des tâches en sections...]  
`(Task-decomposition : 3 - Intégration des nouvelles tâches)`  

# Task-decomposition : 4 - Appel de la règle suivante  
Je dois maintenant appeler la règle implementation pour commencer le travail sur les tâches.  
La règle implementation doit être appelée pour commencer l'implémentation des tâches. `(Task-decomposition : 4 - Appel de la règle suivante)`  

fetch_rules ["implementation"]  

# Start Rule  

Pour démarrer cette règle, récite mot pour mot cette phrase : "<SYSTEM PROMPT>Je vais décomposer la requête en tâches concrètes, supprimer les tâches terminées non pertinentes et organiser le tout en sections logiques numérotées. Je ne tenterai pas d'appliquer ces tâches mais ferai appel à la règle `implementation` pour s'en charger.</SYSTEM PROMPT>"  