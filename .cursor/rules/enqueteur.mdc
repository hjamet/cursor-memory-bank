---
alwaysApply: false
description: Guide m√©thodologique pour identifier syst√©matiquement l'origine pr√©cise d'un bug via hypoth√®ses, logs de d√©bogage et analyse
---

# R√®gle Enqu√™teur : Identification Syst√©matique des Bugs üïµÔ∏è

## Principe Fondamental : Fail-Fast Appliqu√© au D√©bogage

Cette r√®gle impl√©mente le principe "Fail-Fast" dans le contexte du d√©bogage : **identifier rapidement et pr√©cis√©ment l'origine du bug sans le masquer**. L'objectif n'est PAS de r√©soudre le bug, mais de le localiser avec une pr√©cision chirurgicale pour permettre une correction cibl√©e.

**Philosophie** : Un bug mal localis√© est un bug qui reviendra. Mieux vaut √©chouer rapidement avec une origine claire qu'un contournement qui masque la cause racine.

## Processus M√©thodologique en 5 √âtapes

### ‚ö†Ô∏è R√àGLE CRITIQUE : Indication Obligatoire de l'√âtape

L'agent DOIT **toujours** indiquer son √©tape actuelle avec des titres markdown explicites :
- `## √âtape 1 : Formulation d'hypoth√®ses`
- `## √âtape 2 : Placement de logs de d√©bogage`
- `## √âtape 3 : Ex√©cution et r√©cup√©ration des logs`
- `## √âtape 4 : Analyse des r√©sultats`
- `## √âtape 5 : Nettoyage et rapport final`

---

## √âtape 1 : Formulation d'Hypoth√®ses üéØ

### Objectif
Formuler 3-5 hypoth√®ses sur l'origine probable du bug, test√©es en parall√®le pour maximiser l'efficacit√©.

### M√©thodologie
1. **Analyse du contexte** : Comprendre le comportement attendu vs observ√©
2. **Identification des points de d√©faillance** : Variables, fonctions, conditions, flux d'ex√©cution
3. **Priorisation** : Classer les hypoth√®ses par probabilit√© et impact
4. **Formulation claire** : Chaque hypoth√®se doit √™tre testable et sp√©cifique

### Exemple de formulation
```markdown
**Hypoth√®se 1** : La variable `user_id` est `None` lors de l'appel √† `get_user_profile()`
**Hypoth√®se 2** : La connexion √† la base de donn√©es √©choue silencieusement
**Hypoth√®se 3** : Le middleware d'authentification ne valide pas correctement le token
**Hypoth√®se 4** : La fonction `validate_input()` retourne `True` pour des donn√©es invalides
**Hypoth√®se 5** : Race condition entre deux processus acc√©dant √† la m√™me ressource
```

---

## √âtape 2 : Placement de Logs de D√©bogage üìù

### Objectif
Ins√©rer des logs standards (sans marqueur sp√©cial) et des `exit()` strat√©giques pour valider chaque hypoth√®se.

### R√®gles de placement
- **Logs informatifs** : Dictionnaires de variables avec formatage contr√¥l√© et limitation de caract√®res
- **Exit strat√©giques** : Arr√™t du programme juste apr√®s les points de validation cl√©s - **CRITIQUE pour √©viter les boucles infinies**
- **Pas de marqueurs** : Utiliser des logs standards pour faciliter le nettoyage
- **Granularit√© progressive** : Commencer large, puis affiner selon les r√©sultats
- **Protection contre les boucles** : Exit obligatoire apr√®s logs dans des boucles fr√©quentes

### Format standard des logs
```python
# Format recommand√© : dictionnaire avec limitation de caract√®res
print({
    "user_id": str(user_id)[:100],
    "db_connected": str(db.is_connected())[:50],
    "token_valid": str(validate_token(token))[:50],
    "request_headers": str(request.headers)[:200]
})

# Exit strat√©gique apr√®s validation - OBLIGATOIRE pour √©viter les boucles
if user_id is None:
    print({"error": "user_id is None", "location": "auth_middleware"})
    exit(1)
```

### ‚ö†Ô∏è R√àGLES CRITIQUES POUR LES LOGS

1. **Format dictionnaire obligatoire** : Toujours utiliser `{"cl√©": str(valeur)[:limite]}`
2. **Limitation de caract√®res** : Maximum 100-500 caract√®res par valeur selon l'importance
3. **Exit apr√®s boucles** : Si log dans une boucle, exit imm√©diatement apr√®s pour √©viter le spam
4. **Cl√©s descriptives** : Utiliser des noms explicites (`user_id`, `db_status`, `validation_result`)

### Placement des exit()
- **Apr√®s validation d'hypoth√®se** : Confirmer que l'hypoth√®se est correcte
- **Avant action critique** : √âviter les effets de bord
- **Points de d√©cision** : Branches conditionnelles importantes
- **üö® PROTECTION CONTRE LES BOUCLES** : Exit imm√©diat apr√®s logs dans des boucles fr√©quentes
- **Arr√™t contr√¥l√©** : Permettre √† l'utilisateur d'effectuer des actions (ex: requ√™te web) puis r√©cup√©rer les logs

---

## √âtape 3 : Ex√©cution et R√©cup√©ration des Logs üöÄ

### Objectif
Lancer le programme dans les conditions propices au bug et r√©cup√©rer tous les logs.

### M√©thodes d'ex√©cution
1. **Ex√©cution directe** : `python main.py` ou `npm start`
2. **Script de debug temporaire** : Cr√©er `debug_test_scenario.py` √† la racine
3. **Conditions sp√©cifiques** : Reproduire l'environnement exact du bug

### R√®gles pour les scripts temporaires
- **Nommage** : Pr√©fixe `debug_` + description (ex: `debug_api_call.py`)
- **Localisation** : √Ä la racine du projet
- **Contenu** : Code minimal pour reproduire le bug
- **Authenticit√©** : Tester le v√©ritable code, pas une simulation

### Exemple de script temporaire
```python
# debug_api_call.py
import requests
import json

# Reproduire exactement les conditions du bug
headers = {"Authorization": "Bearer invalid_token"}
response = requests.get("http://localhost:3000/api/users", headers=headers)
print(f"Status: {response.status_code}")
print(f"Response: {response.text}")
```

### R√©cup√©ration des logs
- **Capturer TOUS les outputs** : stdout, stderr, fichiers de log
- **Pr√©server l'ordre** : Maintenir la chronologie des √©v√©nements
- **Contextualiser** : Noter les conditions d'ex√©cution

---

## √âtape 4 : Analyse des R√©sultats üîç

### Objectif
D√©cider si les logs permettent d'identifier CLAIREMENT l'origine du bug.

### Crit√®res de validation
‚úÖ **Origine clairement identifi√©e** : Les logs montrent exactement o√π et pourquoi le bug se produit
‚ùå **Origine floue** : Les logs indiquent un probl√®me mais pas sa cause pr√©cise
‚ùå **Hypoth√®ses incorrectes** : Aucune des hypoth√®ses n'est valid√©e

### D√©cisions possibles
- **Passage √† l'√©tape 5** : Origine clairement identifi√©e
- **Retour √† l'√©tape 1** : Toutes les hypoth√®ses √©taient incorrectes
- **Retour √† l'√©tape 2** : Hypoth√®ses prometteuses mais logs insuffisants

### Exemple d'analyse
```markdown
**R√©sultats des logs** :
{
    "user_id": "None",
    "db_connected": "True", 
    "token_valid": "False",
    "validation_error": "silent_failure"
}

**Conclusion** : L'origine est clairement identifi√©e : `user_id` est `None` 
car le token est invalide, mais la validation √©choue silencieusement.
Le bug se situe dans la fonction `extract_user_id_from_token()`.
```

---

## √âtape 5 : Nettoyage et Rapport Final üßπ

### Objectif
Supprimer tous les ajouts temporaires et fournir un r√©sum√© d√©taill√© de l'origine du bug.

### Nettoyage obligatoire
1. **Supprimer tous les logs** ajout√©s lors de l'√©tape 2
2. **Supprimer tous les scripts** `debug_*.py` cr√©√©s
3. **Supprimer tous les exit()** temporaires
4. **V√©rifier la propret√©** : `git status` doit √™tre clean

### V√©rification de propret√©
```bash
git status
# Doit afficher : "nothing to commit, working tree clean"
```

### Rapport final obligatoire
Le rapport doit contenir :

#### R√©sum√© Ex√©cutif
- **Bug identifi√©** : Description claire du comportement probl√©matique
- **Origine pr√©cise** : Fichier, fonction, ligne exacte (si possible)
- **Cause racine** : Pourquoi le bug se produit

#### D√©tails Techniques
- **Hypoth√®ses test√©es** : Liste des hypoth√®ses valid√©es/invalid√©es
- **Logs d√©cisifs** : Les logs qui ont permis l'identification
- **Conditions de reproduction** : Environnement exact n√©cessaire

#### Recommandations
- **Priorit√© de correction** : Critique/Haute/Moyenne/Basse
- **Impact estim√©** : Utilisateurs affect√©s, fonctionnalit√©s impact√©es
- **Complexit√© de correction** : Estimation du temps n√©cessaire

### Exemple de rapport final
```markdown
## Rapport d'Enqu√™te : Bug d'Authentification API

### R√©sum√© Ex√©cutif
**Bug** : L'API retourne 200 OK m√™me avec des tokens invalides
**Origine** : `src/auth/token_validator.py:47` - fonction `validate_token()` retourne `True` par d√©faut
**Cause racine** : Logique de validation invers√©e dans la condition `if not token.is_valid()`

### D√©tails Techniques
**Hypoth√®ses test√©es** :
- ‚úÖ Hypoth√®se 1 : Token invalide accept√© (valid√©e)
- ‚ùå Hypoth√®se 2 : Probl√®me de connexion DB (invalid√©e)
- ‚ùå Hypoth√®se 3 : Middleware d√©faillant (invalid√©e)

**Logs d√©cisifs** :
```json
{
    "token_validation_result": "True",
    "token_is_valid": "False", 
    "validation_logic_error": "inverted_condition"
}
```

**Conditions de reproduction** : Token JWT expir√© ou malform√©

### Recommandations
**Priorit√©** : Critique (s√©curit√©)
**Impact** : Tous les utilisateurs avec tokens invalides
**Complexit√©** : Faible (1 ligne √† corriger)
```

---

## Exemples D√©taill√©s

### Exemple 1 : Bug dans une API Web üåê

**Contexte** : L'API retourne 500 au lieu de 401 pour les tokens invalides

#### √âtape 1 : Hypoth√®ses
- Le middleware d'auth ne catch pas les exceptions
- La validation du token √©choue silencieusement
- Le format du token est incorrect
- La cl√© de signature est mauvaise

#### √âtape 2 : Logs plac√©s
```python
# Dans le middleware d'auth - format dictionnaire avec limitation
print({
    "received_token": str(token[:20]) + "..." if len(token) > 20 else str(token),
    "token_format_valid": str(is_jwt_format(token))[:50],
    "token_signature_valid": str(verify_signature(token))[:50],
    "middleware_step": "token_validation"
})

# Exit strat√©gique apr√®s validation - CRITIQUE pour √©viter les boucles
if not verify_signature(token):
    print({
        "error": "Invalid signature detected",
        "location": "auth_middleware",
        "action": "stopping_execution"
    })
    exit(1)
```

#### √âtape 3 : Ex√©cution
```bash
python debug_api_test.py
# Logs r√©cup√©r√©s montrent le probl√®me
```

#### √âtape 4 : Analyse
Les logs montrent que la signature est invalide mais l'exception n'est pas catch√©e.

#### √âtape 5 : Rapport
Origine identifi√©e : Exception non g√©r√©e dans `verify_signature()` ligne 23.

### Exemple 2 : Bug de Logique M√©tier üíº

**Contexte** : Calcul de prix incorrect pour les commandes group√©es

#### √âtape 1 : Hypoth√®ses
- La r√©duction n'est pas appliqu√©e
- Le calcul de quantit√© est erron√©
- Les prix unitaires sont incorrects
- La logique de groupement √©choue

#### √âtape 2 : Logs plac√©s
```python
# Dans calculate_order_total() - format dictionnaire avec limitation
print({
    "items_count": str(len(items))[:50],
    "unit_prices": str([item.price for item in items])[:200],
    "discount_rate": str(get_discount_rate(items))[:50],
    "subtotal": str(sum(item.price for item in items))[:100],
    "calculation_step": "before_final_total"
})

# Exit avant calcul final - CRITIQUE pour √©viter les boucles
total = calculate_final_total(subtotal, discount_rate)
print({
    "final_total": str(total)[:100],
    "calculation_complete": "true",
    "action": "stopping_for_analysis"
})
exit(1)
```

#### √âtape 3 : Ex√©cution
Script de test avec commande de 5 articles.

#### √âtape 4 : Analyse
Les logs montrent que `discount_rate` est 0 alors qu'il devrait √™tre 0.1.

#### √âtape 5 : Rapport
Origine identifi√©e : `get_discount_rate()` ne compte pas correctement les articles √©ligibles.

---

## R√®gles de S√©curit√© et Bonnes Pratiques

### ‚ö†Ô∏è Interdictions Absolues
- **Ne jamais simuler** : Tester le v√©ritable code, pas une approximation
- **Ne jamais masquer** : Les logs doivent r√©v√©ler, pas cacher
- **Ne jamais contourner** : Identifier la cause, pas les sympt√¥mes
- **Ne jamais saturer la console** : Limiter les logs √† des dictionnaires avec caract√®res limit√©s
- **Ne jamais laisser des boucles sans exit** : Protection obligatoire contre les logs en boucle

### ‚úÖ Obligations
- **Nettoyage complet** : Le repo doit √™tre identique √† l'√©tat initial
- **Logs clairs** : Format dictionnaire avec limitation de caract√®res obligatoire
- **Exit strat√©giques** : Protection contre les boucles infinies et contr√¥le de l'ex√©cution
- **Rapport d√©taill√©** : Suffisamment pr√©cis pour permettre la correction

### üîÑ It√©rations
- **Maximum 3 cycles** : Si apr√®s 3 it√©rations l'origine n'est pas claire, documenter les tentatives
- **Progression logique** : Chaque it√©ration doit affiner la localisation
- **Tra√ßabilit√©** : Garder une trace des hypoth√®ses test√©es

---

## Activation de la R√®gle

Cette r√®gle est activ√©e manuellement par l'utilisateur lors de sessions de d√©bogage. Pour l'utiliser :

1. **D√©clencher** : "Utilise la r√®gle enqu√™teur pour identifier l'origine de ce bug"
2. **Contextualiser** : Fournir la description du bug et les conditions de reproduction
3. **Suivre** : L'agent suivra automatiquement le processus en 5 √©tapes
4. **Valider** : V√©rifier que le repo est propre apr√®s l'enqu√™te

**Rappel** : Cette r√®gle identifie, ne corrige pas. Une fois l'origine claire, c'est √† l'utilisateur ou √† une autre r√®gle de proc√©der √† la correction.