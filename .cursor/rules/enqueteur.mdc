---
alwaysApply: false
description: Guide m√©thodologique pour identifier syst√©matiquement l'origine pr√©cise d'un bug via hypoth√®ses, logs de d√©bogage et analyse
---

# R√®gle Enqu√™teur : Identification Syst√©matique des Bugs üïµÔ∏è

## Principe Fondamental : Fail-Fast Appliqu√© au D√©bogage

Cette r√®gle impl√©mente le principe "Fail-Fast" dans le contexte du d√©bogage : **identifier rapidement et pr√©cis√©ment l'origine du bug sans le masquer**. L'objectif n'est PAS de r√©soudre le bug, mais de le localiser avec une pr√©cision chirurgicale pour permettre une correction cibl√©e.

**Philosophie** : Un bug mal localis√© est un bug qui reviendra. Mieux vaut √©chouer rapidement avec une origine claire qu'un contournement qui masque la cause racine.

## Processus M√©thodologique en 5 √âtapes

### ‚ö†Ô∏è R√àGLE CRITIQUE : Indication Obligatoire de l'√âtape

L'agent DOIT **toujours** indiquer son √©tape actuelle avec des titres markdown explicites :
- `## √âtape 1.a : Exploration des fichiers de code`
- `## √âtape 1.b : Formulation d'hypoth√®ses`
- `## √âtape 2 : Placement de logs de d√©bogage`
- `## √âtape 3 : Ex√©cution et r√©cup√©ration des logs`
- `## √âtape 4 : Analyse des r√©sultats`
- `## √âtape 4.a : Questionnement "POURQUOI" obligatoire`
- `## √âtape 4.b : D√©cision de poursuite ou d'it√©ration`
- `## √âtape 5 : Nettoyage et rapport final`

---

## √âtape 1.a : Exploration des Fichiers de Code üîç

### Objectif
Analyser en profondeur le code pour comprendre le contexte, les flux d'ex√©cution et identifier tous les points de d√©faillance potentiels.

### M√©thodologie d'exploration
1. **Cartographie du code** : Identifier tous les fichiers impliqu√©s dans le bug
2. **Analyse des flux** : Comprendre le parcours d'ex√©cution complet
3. **Identification des d√©pendances** : Variables, fonctions, services externes
4. **Points critiques** : Conditions, validations, transformations de donn√©es
5. **Contexte d'ex√©cution** : Environnement, configuration, √©tat initial

### Outils d'exploration
- **Recherche s√©mantique** : `codebase_search` pour comprendre les fonctionnalit√©s
- **Analyse de fichiers** : `read_file` pour examiner le code source
- **Recherche de patterns** : `grep` pour trouver des motifs sp√©cifiques
- **Navigation** : `list_dir` pour comprendre la structure

### Exemple d'exploration
```markdown
**Fichiers identifi√©s** :
- `src/auth/middleware.py` : Middleware d'authentification
- `src/auth/token_validator.py` : Validation des tokens JWT
- `src/database/connection.py` : Gestion des connexions DB
- `src/api/users.py` : Endpoint utilisateur

**Flux d'ex√©cution** :
1. Requ√™te HTTP ‚Üí Middleware auth ‚Üí Validation token ‚Üí DB query ‚Üí Response
2. Points critiques : validation token, extraction user_id, requ√™te DB

**D√©pendances identifi√©es** :
- Variable `user_id` extraite du token
- Fonction `verify_signature()` pour validation
- Connexion DB pour requ√™te utilisateur
```

---

## √âtape 1.b : Formulation d'Hypoth√®ses üéØ

### Objectif
Formuler 3-5 hypoth√®ses pr√©cises sur l'origine probable du bug, bas√©es sur l'exploration approfondie du code.

### M√©thodologie
1. **Synth√®se de l'exploration** : Utiliser les informations collect√©es √† l'√©tape 1.a
2. **Identification des points de d√©faillance** : Variables, fonctions, conditions, flux d'ex√©cution
3. **Priorisation** : Classer les hypoth√®ses par probabilit√© et impact
4. **Formulation claire** : Chaque hypoth√®se doit √™tre testable et sp√©cifique
5. **Approfondissement** : Ne pas se satisfaire d'hypoth√®ses superficielles

### Exemple de formulation
```markdown
**Hypoth√®se 1** : La variable `user_id` est `None` lors de l'appel √† `get_user_profile()` car `extract_user_id_from_token()` √©choue silencieusement
**Hypoth√®se 2** : La connexion √† la base de donn√©es √©choue silencieusement dans `db.get_user(user_id)`
**Hypoth√®se 3** : Le middleware d'authentification ne valide pas correctement le token dans `verify_signature()`
**Hypoth√®se 4** : La fonction `validate_input()` retourne `True` pour des donn√©es invalides dans `sanitize_user_data()`
**Hypoth√®se 5** : Race condition entre deux processus acc√©dant √† la m√™me ressource dans `update_user_cache()`
```

### ‚ö†Ô∏è R√àGLE CRITIQUE : Ne Pas Se Satisfaire de Solutions Simples
- **Creuser en profondeur** : Ne pas accepter la premi√®re explication qui semble logique
- **It√©rer si n√©cessaire** : Revenir aux √©tapes 1.a ou 1.b si le moindre doute subsiste
- **Preuve absolue** : Identifier la CAUSE, pas la cons√©quence
- **Localisation pr√©cise** : Savoir exactement quelle ligne cause le probl√®me

---

## √âtape 2 : Placement de Logs de D√©bogage üìù

### Objectif
Ins√©rer des logs standards (sans marqueur sp√©cial) et des `exit()` strat√©giques pour valider chaque hypoth√®se.

### R√®gles de placement
- **Logs informatifs** : Dictionnaires de variables avec formatage contr√¥l√© et limitation de caract√®res
- **Exit strat√©giques** : Arr√™t du programme juste apr√®s les points de validation cl√©s - **CRITIQUE pour √©viter les boucles infinies**
- **Pas de marqueurs** : Utiliser des logs standards pour faciliter le nettoyage
- **Granularit√© progressive** : Commencer large, puis affiner selon les r√©sultats
- **Protection contre les boucles** : Exit obligatoire apr√®s logs dans des boucles fr√©quentes

### Format standard des logs
```python
# Format recommand√© : dictionnaire avec limitation de caract√®res
print({
    "user_id": str(user_id)[:100],
    "db_connected": str(db.is_connected())[:50],
    "token_valid": str(validate_token(token))[:50],
    "request_headers": str(request.headers)[:200]
})

# Exit strat√©gique apr√®s validation - OBLIGATOIRE pour √©viter les boucles
if user_id is None:
    print({"error": "user_id is None", "location": "auth_middleware"})
    exit(1)
```

### ‚ö†Ô∏è R√àGLES CRITIQUES POUR LES LOGS

1. **Format dictionnaire obligatoire** : Toujours utiliser `{"cl√©": str(valeur)[:limite]}`
2. **Limitation de caract√®res** : Maximum 100-500 caract√®res par valeur selon l'importance
3. **Exit apr√®s boucles** : Si log dans une boucle, exit imm√©diatement apr√®s pour √©viter le spam
4. **Cl√©s descriptives** : Utiliser des noms explicites (`user_id`, `db_status`, `validation_result`)

### Placement des exit()
- **Apr√®s validation d'hypoth√®se** : Confirmer que l'hypoth√®se est correcte
- **Avant action critique** : √âviter les effets de bord
- **Points de d√©cision** : Branches conditionnelles importantes
- **üö® PROTECTION CONTRE LES BOUCLES** : Exit imm√©diat apr√®s logs dans des boucles fr√©quentes
- **Arr√™t contr√¥l√©** : Permettre √† l'utilisateur d'effectuer des actions (ex: requ√™te web) puis r√©cup√©rer les logs

### Strat√©gie de Logs "Avant/Apr√®s" Obligatoire

Pour identifier la ligne exacte du bug, tu DOIS placer des logs en "sandwich" :

**Log AVANT** : Juste avant la ligne suspecte
- V√©rifie que toutes les variables d'entr√©e sont correctes
- Confirme que l'√©tat du syst√®me est attendu
- Valide que les conditions sont normales

**Log APR√àS** : Juste apr√®s la ligne suspecte
- Capture le r√©sultat de l'op√©ration
- Compare avec le r√©sultat attendu
- Identifie l'incoh√©rence ou l'erreur

**Exemple concret** :
```python
# Log AVANT - tout doit √™tre normal ici
print({
    "BEFORE_line_47": "true",
    "a": str(a)[:50],
    "b": str(b)[:50],
    "operation_expected": "addition",
    "state": "NORMAL"
})

# Ligne suspecte 47
result = a - b  # BUG ICI : devrait √™tre a + b

# Log APR√àS - le probl√®me doit appara√Ætre ici
print({
    "AFTER_line_47": "true",
    "result": str(result)[:50],
    "expected": str(a + b)[:50],
    "state": "ANOMALIE_DETECTED" if result != (a + b) else "NORMAL"
})
exit(1)  # Arr√™t pour analyse
```

---

## √âtape 3 : Ex√©cution et R√©cup√©ration des Logs üöÄ

### Objectif
Lancer le programme dans les conditions propices au bug et r√©cup√©rer tous les logs.

### M√©thodes d'ex√©cution
1. **Ex√©cution directe** : `python main.py` ou `npm start`
2. **Script de debug temporaire** : Cr√©er `debug_test_scenario.py` √† la racine
3. **Conditions sp√©cifiques** : Reproduire l'environnement exact du bug

### R√®gles pour les scripts temporaires
- **Nommage** : Pr√©fixe `debug_` + description (ex: `debug_api_call.py`)
- **Localisation** : √Ä la racine du projet
- **Contenu** : Code minimal pour reproduire le bug
- **Authenticit√©** : Tester le v√©ritable code, pas une simulation

### Exemple de script temporaire
```python
# debug_api_call.py
import requests
import json

# Reproduire exactement les conditions du bug
headers = {"Authorization": "Bearer invalid_token"}
response = requests.get("http://localhost:3000/api/users", headers=headers)
print(f"Status: {response.status_code}")
print(f"Response: {response.text}")
```

### R√©cup√©ration des logs
- **Capturer TOUS les outputs** : stdout, stderr, fichiers de log
- **Pr√©server l'ordre** : Maintenir la chronologie des √©v√©nements
- **Contextualiser** : Noter les conditions d'ex√©cution

---

## √âtape 4 : Analyse des R√©sultats üîç

### Objectif
Analyser les logs r√©cup√©r√©s pour identifier les patterns et sympt√¥mes du bug.

### Crit√®res d'analyse
‚úÖ **Sympt√¥mes clairs** : Les logs montrent des valeurs inattendues ou des erreurs
‚ùå **Logs insuffisants** : Pas assez d'informations pour comprendre le probl√®me
‚ùå **Hypoth√®ses invalid√©es** : Aucune des hypoth√®ses n'est confirm√©e par les logs

### M√©thodologie d'analyse
1. **Examen des logs** : Identifier les valeurs inattendues ou les erreurs
2. **Corr√©lation avec les hypoth√®ses** : V√©rifier quelles hypoth√®ses sont valid√©es
3. **Identification des sympt√¥mes** : Comprendre ce qui ne fonctionne pas
4. **Pr√©paration du questionnement** : Pr√©parer les questions "POURQUOI" pour l'√©tape 4.a

### Exemple d'analyse
```markdown
**R√©sultats des logs** :
{
    "user_id": "None",
    "db_connected": "True", 
    "token_valid": "False",
    "validation_error": "silent_failure"
}

**Sympt√¥mes identifi√©s** :
- `user_id` est `None` alors qu'il devrait contenir un ID utilisateur
- `token_valid` est `False` mais aucune erreur n'est lev√©e
- La validation √©choue silencieusement

**Hypoth√®ses valid√©es** :
- ‚úÖ Hypoth√®se 1 : `user_id` est `None` (confirm√©e)
- ‚úÖ Hypoth√®se 3 : Validation token √©choue (confirm√©e)
```

---

## √âtape 4.a : Questionnement "POURQUOI" Obligatoire ‚ùì

### Objectif
Se poser la question "POURQUOI" pour chaque sympt√¥me identifi√© et r√©pondre avec certitude absolue.

### ‚ö†Ô∏è R√àGLE CRITIQUE
**Avant de passer √† l'√©tape 4.b, l'agent DOIT obligatoirement se poser la question "POURQUOI" pour chaque sympt√¥me et y r√©pondre avec certitude absolue.**

### Processus de questionnement "POURQUOI"
1. **Identifier le sympt√¥me** : "La variable X a la valeur Y"
2. **Poser la question** : "POURQUOI X a-t-elle la valeur Y ?"
3. **R√©pondre avec pr√©cision** : "Parce que la fonction Z ligne N fait W"
4. **Validation critique OBLIGATOIRE** : V√©rifier que tout est normal AVANT le passage probl√©matique
5. **Validation de la localisation** : Confirmer que le probl√®me appara√Æt BIEN juste apr√®s le passage identifi√©
6. **√âvaluer la certitude** : Suis-je s√ªr √† 100% d'avoir identifi√© l'UNIQUE passage probl√©matique ?

### Exemple de questionnement "POURQUOI"
```markdown
**Sympt√¥me identifi√©** : La liste `actions` est toujours vide
**Question POURQUOI** : POURQUOI la liste `actions` est-elle toujours vide ?

**R√©ponse initiale** : "Parce que la fonction `load_actions()` ligne 23 retourne toujours `[]`"

**Validation critique OBLIGATOIRE** :
- ‚úÖ Tout est normal AVANT ligne 23 : `user` existe, `user.is_active` est `True`
- ‚úÖ Le probl√®me appara√Æt BIEN juste apr√®s ligne 23 : `actions` devient `[]`
- ‚úÖ C'est l'UNIQUE passage probl√©matique : aucune autre fonction ne modifie `actions`

**R√©ponse finale** : "Parce que la fonction `load_actions()` ligne 23 retourne toujours `[]` car la condition `if user.is_active` ligne 25 est toujours `False`"

**√âvaluation** :
- ‚úÖ Cause claire + logique du code + certitude absolue ‚Üí Pr√™t pour √©tape 4.b
- ‚ùå Cause floue OU incertitude OU validation critique √©chou√©e ‚Üí Besoin de plus de logs (retour √©tape 2)
```

### Questions "POURQUOI" typiques
- **POURQUOI** cette variable a-t-elle cette valeur inattendue ?
- **POURQUOI** cette fonction retourne-t-elle ce r√©sultat incorrect ?
- **POURQUOI** cette condition est-elle toujours vraie/fausse ?
- **POURQUOI** cette exception n'est-elle pas catch√©e ?

### ‚ö†Ô∏è VALIDATION CRITIQUE OBLIGATOIRE

**L'agent DOIT √™tre extr√™mement prudent et v√©rifier** :

1. **√âtat normal AVANT le passage probl√©matique** :
   - Toutes les variables ont les valeurs attendues
   - Toutes les conditions sont dans l'√©tat normal
   - Aucun probl√®me n'existe avant la ligne identifi√©e

2. **Probl√®me appara√Æt BIEN juste apr√®s** :
   - Le sympt√¥me se manifeste imm√©diatement apr√®s le passage identifi√©
   - Pas de d√©lai ou d'autres √©tapes interm√©diaires
   - Lien direct et imm√©diat entre cause et effet

3. **UNIQUE passage probl√©matique** :
   - Aucune autre partie du code ne peut causer le m√™me probl√®me
   - Le passage identifi√© est la seule source possible du bug
   - Pas de causes multiples ou alternatives

**Si une seule de ces validations √©choue** ‚Üí Retour √† l'√©tape 2 pour plus de logs

### ‚ö†Ô∏è VALIDATION CRITIQUE OBLIGATOIRE

**Avant de passer √† l'√©tape 4.b, l'agent DOIT OBLIGATOIREMENT ajouter des logs strat√©giques pour prouver chaque hypoth√®se avec des preuves concr√®tes.**

**Instructions explicites** :
- "Si tu n'as pas de logs prouvant que tout est normal AVANT la ligne identifi√©e, retourne √† l'√©tape 2 pour ajouter ces logs"
- "Si tu n'as pas de logs prouvant que le probl√®me appara√Æt APR√àS cette ligne, retourne √† l'√©tape 2 pour ajouter ces logs"
- "Tu ne peux PAS affirmer avoir trouv√© la ligne exacte sans ces deux preuves par logs"

**Format des preuves obligatoires** :

1. **Preuve AVANT** : Logs juste avant la ligne suspecte montrant que tout est normal
2. **Preuve APR√àS** : Logs juste apr√®s la ligne suspecte montrant l'anomalie

**Exemple concret** :
```markdown
**Mauvaise identification** :
"Le bug vient de la fonction `calculate_total()` car elle retourne un mauvais r√©sultat"
‚ùå Pas de ligne pr√©cise, pas de preuve avant/apr√®s

**Bonne identification** :
"Le bug vient de la ligne 47 dans `calculate_total()` : `result = a - b` au lieu de `result = a + b`"
**Preuve AVANT** (logs ligne 46) : `{"a": 100, "b": 50, "operation": "addition_expected"}`
**Preuve APR√àS** (logs ligne 48) : `{"result": 50, "expected": 150, "problem": "VALEUR_INCORRECTE"}`
‚úÖ Ligne exacte + preuve que tout est normal avant + preuve du probl√®me apr√®s
```

---

## √âtape 4.b : D√©cision de Poursuite ou d'It√©ration üéØ

### Objectif
D√©cider si l'origine du bug est suffisamment claire pour passer au rapport final ou s'il faut continuer √† creuser.

### Checkpoint de Validation : 3 Questions Obligatoires

Avant de passer √† l'√©tape 5, l'agent DOIT r√©pondre OUI aux 3 questions suivantes avec des PREUVES par logs :

**Question 1 : Ai-je la ligne EXACTE du bug ?**
- ‚úÖ OUI : "Ligne 47 de `src/calculator.py` : `result = a - b`"
- ‚ùå NON : "Le probl√®me vient de la fonction `calculate_total()`" (trop vague)
- ‚ùå NON : "Quelque part dans le module de calcul" (aucune pr√©cision)

**Question 2 : Ai-je des logs prouvant que tout est NORMAL AVANT cette ligne ?**
- ‚úÖ OUI : Logs ligne 46 montrant `{"a": 100, "b": 50}` avec valeurs attendues
- ‚ùå NON : Pas de logs avant la ligne identifi√©e
- ‚ùå NON : Logs pr√©sents mais pas assez proches de la ligne suspecte

**Question 3 : Ai-je des logs prouvant que le PROBL√àME appara√Æt APR√àS cette ligne ?**
- ‚úÖ OUI : Logs ligne 48 montrant `{"result": 50, "expected": 150}`
- ‚ùå NON : Pas de logs apr√®s la ligne identifi√©e
- ‚ùå NON : Logs pr√©sents mais ne montrent pas clairement l'incoh√©rence

**D√âCISION FINALE** :
- Si les 3 r√©ponses sont OUI avec preuves ‚Üí ‚úÖ Passage √† l'√©tape 5
- Si UNE SEULE r√©ponse est NON ‚Üí ‚ùå RETOUR √† l'√©tape 2 pour ajouter des logs strat√©giques

### ‚ö†Ô∏è R√àGLE DE PROFONDEUR : Fonctions Locales

Avant de valider que tu as trouv√© la ligne exacte du bug, v√©rifie :

**La ligne identifi√©e est-elle un appel √† une FONCTION LOCALE ?**

**Fonction locale** = fonction d√©finie dans le projet (pas une biblioth√®que externe comme `len()`, `print()`, `requests.get()`)

**Exemples** :
- `result = calculate_total(items)` ‚Üí Fonction locale ‚úÖ RENTRER DEDANS
- `data = process_user_data(user)` ‚Üí Fonction locale ‚úÖ RENTRER DEDANS
- `items = json.loads(raw_data)` ‚Üí Biblioth√®que externe ‚ùå Ne pas rentrer
- `total = sum(prices)` ‚Üí Built-in Python ‚ùå Ne pas rentrer

**SI la ligne est un appel de fonction locale** :
1. ‚ùå Tu ne peux PAS affirmer avoir trouv√© le bug
2. ‚ùå Tu dois RENTRER dans cette fonction
3. ‚ùå Tu dois placer des logs DANS cette fonction pour identifier la ligne exacte du probl√®me
4. ‚ùå Tu dois continuer √† creuser jusqu'√† trouver l'instruction primitive (assignation, op√©ration, condition, retour)

**Crit√®re d'arr√™t** : Tu ne peux t'arr√™ter QUE quand la ligne identifi√©e est une instruction primitive :
- Assignation : `x = y + z`
- Op√©ration : `result = a - b`
- Condition : `if user.is_active`
- Retour : `return None`
- Acc√®s : `data['key']`
- etc.

**Exemple d'approfondissement obligatoire** :
```markdown
**It√©ration 1 - INSUFFISANT** :
"Ligne 47 : `total = calculate_order_total(items)` retourne une mauvaise valeur"
‚Üí ‚ùå C'est un appel de fonction locale, il faut rentrer dedans

**It√©ration 2 - INSUFFISANT** :
"Dans `calculate_order_total()` ligne 12 : `discount = get_discount(items)` retourne 0 au lieu de 0.1"
‚Üí ‚ùå C'est encore un appel de fonction locale, il faut continuer

**It√©ration 3 - ACCEPTABLE** :
"Dans `get_discount()` ligne 5 : `if len(items) >= 5` au lieu de `if sum(item.qty for item in items) >= 5`"
‚Üí ‚úÖ C'est une instruction primitive (condition), on peut s'arr√™ter
‚Üí ‚úÖ Avec logs prouvant que `len(items) = 3` et `sum(item.qty) = 8`
```

### Exemples de D√©cisions INACCEPTABLES

‚ùå **Arr√™t pr√©matur√© sur sympt√¥me** :
"J'ai trouv√© que `user_id` est None, donc le bug vient de l'authentification"
‚Üí C'est un SYMPT√îME, pas la ligne exacte du bug

‚ùå **Localisation vague** :
"Le probl√®me est dans la fonction `process_user_data()`"
‚Üí Quelle ligne ? Quelle instruction exactement ?

‚ùå **Pas de preuves avant/apr√®s** :
"Ligne 42 cause le bug car la logique est incorrecte"
‚Üí O√π sont les logs prouvant l'√©tat normal avant et le probl√®me apr√®s ?

‚ùå **Justification logique sans preuve** :
"√áa doit √™tre ligne 15 car c'est la seule qui modifie cette variable"
‚Üí "√áa doit √™tre" n'est pas une preuve. O√π sont les logs ?

### D√©cisions possibles
- **Passage √† l'√©tape 5** : Les 3 questions sont OUI avec preuves ET pas d'appel de fonction locale
- **Retour √† l'√©tape 1.a** : Exploration insuffisante, besoin d'analyser plus de code
- **Retour √† l'√©tape 1.b** : Hypoth√®ses incorrectes ou trop superficielles
- **Retour √† l'√©tape 2** : Logs insuffisants pour r√©pondre aux 3 questions OU fonction locale √† explorer

---

## √âtape 5 : Rapport Final üìã

### Objectif
Fournir un r√©sum√© d√©taill√© de l'origine du bug identifi√©.

### Rapport final obligatoire
Le rapport doit contenir :

#### R√©sum√© Ex√©cutif
- **Bug identifi√©** : Description claire du comportement probl√©matique
- **Origine pr√©cise** : Fichier, fonction, ligne exacte (si possible)
- **Cause racine** : Pourquoi le bug se produit

#### D√©tails Techniques
- **Hypoth√®ses test√©es** : Liste des hypoth√®ses valid√©es/invalid√©es
- **Logs d√©cisifs** : Les logs qui ont permis l'identification
- **Conditions de reproduction** : Environnement exact n√©cessaire

#### Recommandations
- **Priorit√© de correction** : Critique/Haute/Moyenne/Basse
- **Impact estim√©** : Utilisateurs affect√©s, fonctionnalit√©s impact√©es
- **Complexit√© de correction** : Estimation du temps n√©cessaire

### Exemple de rapport final
```markdown
## Rapport d'Enqu√™te : Bug d'Authentification API

### R√©sum√© Ex√©cutif
**Bug** : L'API retourne 200 OK m√™me avec des tokens invalides
**Origine** : `src/auth/token_validator.py:47` - fonction `validate_token()` retourne `True` par d√©faut
**Cause racine** : Logique de validation invers√©e dans la condition `if not token.is_valid()`

### D√©tails Techniques
**Hypoth√®ses test√©es** :
- ‚úÖ Hypoth√®se 1 : Token invalide accept√© (valid√©e)
- ‚ùå Hypoth√®se 2 : Probl√®me de connexion DB (invalid√©e)
- ‚ùå Hypoth√®se 3 : Middleware d√©faillant (invalid√©e)

**Logs d√©cisifs** :
```json
{
    "token_validation_result": "True",
    "token_is_valid": "False", 
    "validation_logic_error": "inverted_condition"
}
```

**Conditions de reproduction** : Token JWT expir√© ou malform√©

### Recommandations
**Priorit√©** : Critique (s√©curit√©)
**Impact** : Tous les utilisateurs avec tokens invalides
**Complexit√©** : Faible (1 ligne √† corriger)
```

---

## Exemples D√©taill√©s

### Exemple 1 : Bug dans une API Web üåê

**Contexte** : L'API retourne 500 au lieu de 401 pour les tokens invalides

#### √âtape 1.a : Exploration des fichiers
**Fichiers analys√©s** :
- `src/auth/middleware.py` : Middleware d'authentification (lignes 15-45)
- `src/auth/token_validator.py` : Validation JWT (lignes 20-80)
- `src/api/users.py` : Endpoint utilisateur (lignes 10-30)

**Flux identifi√©** :
Requ√™te ‚Üí middleware.auth() ‚Üí token_validator.verify() ‚Üí db.get_user() ‚Üí response

#### √âtape 1.b : Hypoth√®ses formul√©es
- Le middleware d'auth ne catch pas les exceptions dans `verify_signature()`
- La validation du token √©choue silencieusement dans `extract_user_id()`
- Le format du token est incorrect mais accept√© par `is_jwt_format()`
- La cl√© de signature est mauvaise dans `verify_signature()` ligne 47

#### √âtape 2 : Logs plac√©s
```python
# Dans token_validator.py - Logs AVANT ligne 23 (appel jwt.decode())
print({
    "BEFORE_line_23": "true",
    "token_exists": str(token is not None)[:50],
    "token_length": str(len(token))[:20],
    "jwt_decode_call": "about_to_call",
    "state": "NORMAL"
})

# Ligne 23 suspecte - ici le probl√®me commence
payload = jwt.decode(token, SECRET_KEY, algorithms=['HS256'])  # Exception non catch√©e

# Log APR√àS ligne 23 - ne sera jamais atteint √† cause de l'exception
print({
    "AFTER_line_23": "true", 
    "payload": str(payload)[:200],
    "state": "NORMAL"
})

# Dans le middleware d'auth - format dictionnaire avec limitation
print({
    "received_token": str(token[:20]) + "..." if len(token) > 20 else str(token),
    "token_format_valid": str(is_jwt_format(token))[:50],
    "middleware_step": "before_verify_signature"
})

token_signature_valid = verify_signature(token)  # Appel qui cause l'exception

print({
    "token_signature_valid": str(token_signature_valid)[:50],
    "middleware_step": "after_verify_signature"
})

exit(1)  # Arr√™t pour analyse
```

#### √âtape 3 : Ex√©cution
```bash
python debug_api_test.py
# Logs r√©cup√©r√©s montrent le probl√®me
```

#### √âtape 4 : Analyse
Les logs montrent que la signature est invalide mais l'exception n'est pas catch√©e.

**Sympt√¥mes identifi√©s** :
- `token_signature_valid` est `False`
- Aucune exception n'est catch√©e
- Le programme continue et retourne 500

#### √âtape 4.a : Questionnement "POURQUOI"
**Question POURQUOI obligatoire** : POURQUOI l'exception n'est-elle pas catch√©e ?
**R√©ponse** : Parce que la fonction `verify_signature()` ligne 23 n'a pas de bloc try/catch autour de `jwt.decode()`, donc l'exception `InvalidSignatureError` remonte et cause le 500.

#### √âtape 4.b : Validation des 3 Questions + R√®gle de Profondeur

**Question 1 : Ai-je la ligne EXACTE du bug ?**
‚úÖ OUI : "Ligne 23 de `src/auth/token_validator.py` : `payload = jwt.decode(token, SECRET_KEY, algorithms=['HS256'])`"

**Question 2 : Ai-je des logs prouvant que tout est NORMAL AVANT cette ligne ?**
‚úÖ OUI : Logs ligne 22 montrent `{"token_exists": "True", "token_length": "145", "state": "NORMAL"}`

**Question 3 : Ai-je des logs prouvant que le PROBL√àME appara√Æt APR√àS cette ligne ?**
‚úÖ OUI : L'exception `InvalidSignatureError` se produit √† la ligne 23, emp√™chant l'ex√©cution des logs ligne 24

**Validation de la r√®gle de profondeur** : 
‚úÖ La ligne 23 n'est PAS un appel de fonction locale (`jwt.decode()` est une biblioth√®que externe)

**D√âCISION FINALE** : ‚úÖ Passage √† l'√©tape 5 - Toutes les conditions sont remplies

#### √âtape 5 : Rapport
**Origine pr√©cise identifi√©e** : Exception non g√©r√©e dans `verify_signature()` ligne 23 de `src/auth/token_validator.py`. **Cause racine** : Absence de try/catch autour de `jwt.decode()`.

### Exemple 2 : Bug de Logique M√©tier üíº

**Contexte** : Calcul de prix incorrect pour les commandes group√©es

#### √âtape 1.a : Exploration des fichiers
**Fichiers analys√©s** :
- `src/orders/calculator.py` : Calcul des prix (lignes 10-60)
- `src/orders/discount.py` : Logique de r√©duction (lignes 5-40)
- `src/orders/models.py` : Mod√®les de commande (lignes 20-80)

**Flux identifi√©** :
Commande ‚Üí calculate_order_total() ‚Üí get_discount_rate() ‚Üí calculate_final_total() ‚Üí prix final

#### √âtape 1.b : Hypoth√®ses formul√©es
- La r√©duction n'est pas appliqu√©e dans `calculate_final_total()` ligne 45
- Le calcul de quantit√© est erron√© dans `get_discount_rate()` ligne 12
- Les prix unitaires sont incorrects dans `extract_unit_prices()` ligne 28
- La logique de groupement √©choue dans `group_items_by_category()` ligne 15

#### √âtape 2 : Logs plac√©s
```python
# Dans discount.py - Logs AVANT ligne 12 de get_discount_rate()
print({
    "BEFORE_line_12": "true",
    "items_count": str(len(items))[:20],
    "items_quantities": str([item.quantity for item in items])[:100],
    "total_quantities": str(sum(item.quantity for item in items))[:20],
    "condition_check": "about_to_check",
    "state": "NORMAL"
})

# Ligne 12 suspecte - ici le bug se produit
if len(items) >= 5:  # BUG : devrait √™tre sum(item.quantity for item in items) >= 5
    return 0.1
else:
    return 0

# Log APR√àS ligne 12 - dans le cas o√π la condition est vraie
print({
    "AFTER_line_12": "true",
    "condition_result": "len(items) >= 5",
    "returned_discount": "0.1",
    "state": "BUG_DETECTED" if len(items) >= 5 and sum(item.quantity for item in items) < 5 else "NORMAL"
})

# Dans calculate_order_total() - pour montrer l'impact
discount_rate = get_discount_rate(items)
print({
    "discount_rate_result": str(discount_rate)[:50],
    "expected_discount": "0.1" if sum(item.quantity for item in items) >= 5 else "0",
    "state": "ANOMALIE_DETECTED" if discount_rate != (0.1 if sum(item.quantity for item in items) >= 5 else 0) else "NORMAL"
})

exit(1)  # Arr√™t pour analyse
```

#### √âtape 3 : Ex√©cution
Script de test avec commande de 5 articles.

#### √âtape 4 : Analyse
Les logs montrent que `discount_rate` est 0 alors qu'il devrait √™tre 0.1.

**Sympt√¥mes identifi√©s** :
- `discount_rate` est `0` au lieu de `0.1`
- `items_count` est `5` (correct)
- Le calcul de r√©duction √©choue

#### √âtape 4.a : Questionnement "POURQUOI"
**Question POURQUOI obligatoire** : POURQUOI `discount_rate` est-il 0 au lieu de 0.1 ?
**R√©ponse** : Parce que la fonction `get_discount_rate()` ligne 12 v√©rifie `if len(items) >= 5` au lieu de `if sum(item.quantity for item in items) >= 5`.

#### √âtape 4.b : Validation des 3 Questions + R√®gle de Profondeur

**Question 1 : Ai-je la ligne EXACTE du bug ?**
‚úÖ OUI : "Ligne 12 de `src/orders/discount.py` : `if len(items) >= 5:` au lieu de `if sum(item.quantity for item in items) >= 5:`"

**Question 2 : Ai-je des logs prouvant que tout est NORMAL AVANT cette ligne ?**
‚úÖ OUI : Logs ligne 11 montrent `{"items_count": 5, "total_quantities": 8, "state": "NORMAL"}` avec donn√©es correctes

**Question 3 : Ai-je des logs prouvant que le PROBL√àME appara√Æt APR√àS cette ligne ?**
‚úÖ OUI : Logs ligne 14 montrent `{"returned_discount": 0, "expected": 0.1, "state": "BUG_DETECTED"}`

**Validation de la r√®gle de profondeur** : 
‚úÖ La ligne 12 est une instruction primitive (condition if), pas un appel de fonction locale

**D√âCISION FINALE** : ‚úÖ Passage √† l'√©tape 5 - Toutes les conditions sont remplies

#### √âtape 5 : Rapport
**Origine pr√©cise identifi√©e** : Condition incorrecte dans `get_discount_rate()` ligne 12 de `src/orders/discount.py`. **Cause racine** : La condition v√©rifie `len(items) >= 5` au lieu de `sum(item.quantity for item in items) >= 5`.

---

## R√®gles de S√©curit√© et Bonnes Pratiques

### ‚ö†Ô∏è Interdictions Absolues
- **Ne jamais simuler** : Tester le v√©ritable code, pas une approximation
- **Ne jamais masquer** : Les logs doivent r√©v√©ler, pas cacher
- **Ne jamais contourner** : Identifier la cause, pas les sympt√¥mes
- **Ne jamais saturer la console** : Limiter les logs √† des dictionnaires avec caract√®res limit√©s
- **Ne jamais laisser des boucles sans exit** : Protection obligatoire contre les logs en boucle
- **Ne jamais passer √† l'√©tape 5 sans r√©pondre √† "POURQUOI"** : Question obligatoire avant le rapport final

### ‚úÖ Obligations
- **Logs clairs** : Format dictionnaire avec limitation de caract√®res obligatoire
- **Exit strat√©giques** : Protection contre les boucles infinies et contr√¥le de l'ex√©cution
- **Question "POURQUOI" obligatoire** : R√©pondre avec certitude avant l'√©tape 5
- **Rapport d√©taill√©** : Suffisamment pr√©cis pour permettre la correction

### üîÑ It√©rations et Approfondissement
- **It√©ration obligatoire** : Si le moindre doute subsiste, revenir aux √©tapes pr√©c√©dentes
- **Creuser en profondeur** : Ne pas accepter la premi√®re explication qui semble logique
- **Preuve absolue requise** : Identifier la CAUSE racine, pas les sympt√¥mes
- **Localisation pr√©cise** : Savoir le fichier, la fonction ET la ligne exacte
- **Tra√ßabilit√©** : Garder une trace de toutes les hypoth√®ses test√©es et des r√©sultats

---

## Erreurs Fr√©quentes √† √âviter

### ‚ùå Erreur 1 : S'arr√™ter sur un sympt√¥me
**Sympt√¥me** : "La variable X est None"
**Cause racine** : "Ligne 23 de fonction Y retourne None car condition Z est fausse"
‚Üí Ne t'arr√™te JAMAIS au sympt√¥me, creuse jusqu'√† la ligne exacte

### ‚ùå Erreur 2 : Accepter une localisation vague
**Vague** : "Le probl√®me est dans le module d'authentification"
**Pr√©cis** : "Ligne 47 de `src/auth/validator.py` : `if token.valid` au lieu de `if token.is_valid()`"
‚Üí File + Function + Ligne + Instruction exacte requises

### ‚ùå Erreur 3 : Se fier √† la logique sans preuves
**Sans preuve** : "√áa doit √™tre ligne 15 car c'est logique"
**Avec preuve** : "Logs montrent qu'avant ligne 15 tout est normal, apr√®s ligne 15 la variable devient incorrecte"
‚Üí Toujours prouver par des logs, jamais par d√©duction pure

### ‚ùå Erreur 4 : Manquer la validation avant/apr√®s
**Incomplet** : "J'ai trouv√© que ligne 42 cause le bug"
**Complet** : "Logs ligne 41 : tout normal. Logs ligne 43 : valeur incorrecte. Donc ligne 42 est le bug"
‚Üí Obligatoire : preuve que tout est normal avant ET probl√®me apr√®s

### ‚ùå Erreur 5 : Confondre cause et cons√©quence
**Cons√©quence** : "L'API retourne 500 √† cause d'une exception"
**Cause** : "Ligne 34 l√®ve une exception car la cl√© 'user_id' n'existe pas dans le dictionnaire"
‚Üí Remonter jusqu'√† la PREMI√àRE instruction qui produit un r√©sultat incorrect

### ‚ùå Erreur 6 : S'arr√™ter √† un appel de fonction locale
**Arr√™t pr√©matur√©** : "Le bug est ligne 47 : `result = calculate_total(items)` retourne une mauvaise valeur"
**Bon approfondissement** : "Le bug est dans `calculate_total()` ligne 15 : `sum += item.price` au lieu de `sum += item.price * item.quantity`"
‚Üí Si la ligne probl√©matique est un APPEL √† une fonction locale (pas une lib externe), RENTRER dans cette fonction et continuer l'enqu√™te
‚Üí Ne s'arr√™ter QUE quand on a trouv√© l'instruction primitive qui cause le probl√®me (assignation, op√©ration, condition, etc.)

---

## Activation de la R√®gle

Cette r√®gle est activ√©e manuellement par l'utilisateur lors de sessions de d√©bogage. Pour l'utiliser :

1. **D√©clencher** : "Utilise la r√®gle enqu√™teur pour identifier l'origine de ce bug"
2. **Contextualiser** : Fournir la description du bug et les conditions de reproduction
3. **Suivre** : L'agent suivra automatiquement le processus en 5 √©tapes
4. **Valider** : V√©rifier que le repo est propre apr√®s l'enqu√™te

**Rappel** : Cette r√®gle identifie, ne corrige pas. Une fois l'origine claire, c'est √† l'utilisateur ou √† une autre r√®gle de proc√©der √† la correction.