---
alwaysApply: false
description: Guide m√©thodologique pour identifier syst√©matiquement l'origine pr√©cise d'un bug via hypoth√®ses, logs de d√©bogage et analyse
---

# R√®gle Enqu√™teur : Identification Syst√©matique des Bugs üïµÔ∏è

## Principe Fondamental : Fail-Fast Appliqu√© au D√©bogage

Cette r√®gle impl√©mente le principe "Fail-Fast" dans le contexte du d√©bogage : **identifier rapidement et pr√©cis√©ment l'origine du bug sans le masquer**. L'objectif n'est PAS de r√©soudre le bug, mais de le localiser avec une pr√©cision chirurgicale pour permettre une correction cibl√©e.

**Philosophie** : Un bug mal localis√© est un bug qui reviendra. Mieux vaut √©chouer rapidement avec une origine claire qu'un contournement qui masque la cause racine.

## Processus M√©thodologique en 5 √âtapes

### ‚ö†Ô∏è R√àGLE CRITIQUE : Indication Obligatoire de l'√âtape

L'agent DOIT **toujours** indiquer son √©tape actuelle avec des titres markdown explicites :
- `## √âtape 1.a : Exploration des fichiers de code`
- `## √âtape 1.b : Formulation d'hypoth√®ses`
- `## √âtape 2 : Placement de logs de d√©bogage`
- `## √âtape 3 : Ex√©cution et r√©cup√©ration des logs`
- `## √âtape 4 : Analyse des r√©sultats`
- `## √âtape 4.a : Questionnement "POURQUOI" obligatoire`
- `## √âtape 4.b : D√©cision de poursuite ou d'it√©ration`
- `## √âtape 5 : Nettoyage et rapport final`

---

## √âtape 1.a : Exploration des Fichiers de Code üîç

### Objectif
Analyser en profondeur le code pour comprendre le contexte, les flux d'ex√©cution et identifier tous les points de d√©faillance potentiels.

### M√©thodologie d'exploration
1. **Cartographie du code** : Identifier tous les fichiers impliqu√©s dans le bug
2. **Analyse des flux** : Comprendre le parcours d'ex√©cution complet
3. **Identification des d√©pendances** : Variables, fonctions, services externes
4. **Points critiques** : Conditions, validations, transformations de donn√©es
5. **Contexte d'ex√©cution** : Environnement, configuration, √©tat initial

### Outils d'exploration
- **Recherche s√©mantique** : `codebase_search` pour comprendre les fonctionnalit√©s
- **Analyse de fichiers** : `read_file` pour examiner le code source
- **Recherche de patterns** : `grep` pour trouver des motifs sp√©cifiques
- **Navigation** : `list_dir` pour comprendre la structure

### Exemple d'exploration
```markdown
**Fichiers identifi√©s** :
- `src/auth/middleware.py` : Middleware d'authentification
- `src/auth/token_validator.py` : Validation des tokens JWT
- `src/database/connection.py` : Gestion des connexions DB
- `src/api/users.py` : Endpoint utilisateur

**Flux d'ex√©cution** :
1. Requ√™te HTTP ‚Üí Middleware auth ‚Üí Validation token ‚Üí DB query ‚Üí Response
2. Points critiques : validation token, extraction user_id, requ√™te DB

**D√©pendances identifi√©es** :
- Variable `user_id` extraite du token
- Fonction `verify_signature()` pour validation
- Connexion DB pour requ√™te utilisateur
```

---

## √âtape 1.b : Formulation d'Hypoth√®ses üéØ

### Objectif
Formuler 3-5 hypoth√®ses pr√©cises sur l'origine probable du bug, bas√©es sur l'exploration approfondie du code.

### M√©thodologie
1. **Synth√®se de l'exploration** : Utiliser les informations collect√©es √† l'√©tape 1.a
2. **Identification des points de d√©faillance** : Variables, fonctions, conditions, flux d'ex√©cution
3. **Priorisation** : Classer les hypoth√®ses par probabilit√© et impact
4. **Formulation claire** : Chaque hypoth√®se doit √™tre testable et sp√©cifique
5. **Approfondissement** : Ne pas se satisfaire d'hypoth√®ses superficielles

### Exemple de formulation
```markdown
**Hypoth√®se 1** : La variable `user_id` est `None` lors de l'appel √† `get_user_profile()` car `extract_user_id_from_token()` √©choue silencieusement
**Hypoth√®se 2** : La connexion √† la base de donn√©es √©choue silencieusement dans `db.get_user(user_id)`
**Hypoth√®se 3** : Le middleware d'authentification ne valide pas correctement le token dans `verify_signature()`
**Hypoth√®se 4** : La fonction `validate_input()` retourne `True` pour des donn√©es invalides dans `sanitize_user_data()`
**Hypoth√®se 5** : Race condition entre deux processus acc√©dant √† la m√™me ressource dans `update_user_cache()`
```

### ‚ö†Ô∏è R√àGLE CRITIQUE : Ne Pas Se Satisfaire de Solutions Simples
- **Creuser en profondeur** : Ne pas accepter la premi√®re explication qui semble logique
- **It√©rer si n√©cessaire** : Revenir aux √©tapes 1.a ou 1.b si le moindre doute subsiste
- **Preuve absolue** : Identifier la CAUSE, pas la cons√©quence
- **Localisation pr√©cise** : Savoir exactement quelle ligne cause le probl√®me

---

## √âtape 2 : Placement de Logs de D√©bogage üìù

### Objectif
Ins√©rer des logs standards (sans marqueur sp√©cial) et des `exit()` strat√©giques pour valider chaque hypoth√®se.

### R√®gles de placement
- **Logs informatifs** : Dictionnaires de variables avec formatage contr√¥l√© et limitation de caract√®res
- **Exit strat√©giques** : Arr√™t du programme juste apr√®s les points de validation cl√©s - **CRITIQUE pour √©viter les boucles infinies**
- **Pas de marqueurs** : Utiliser des logs standards pour faciliter le nettoyage
- **Granularit√© progressive** : Commencer large, puis affiner selon les r√©sultats
- **Protection contre les boucles** : Exit obligatoire apr√®s logs dans des boucles fr√©quentes

### Format standard des logs
```python
# Format recommand√© : dictionnaire avec limitation de caract√®res
print({
    "user_id": str(user_id)[:100],
    "db_connected": str(db.is_connected())[:50],
    "token_valid": str(validate_token(token))[:50],
    "request_headers": str(request.headers)[:200]
})

# Exit strat√©gique apr√®s validation - OBLIGATOIRE pour √©viter les boucles
if user_id is None:
    print({"error": "user_id is None", "location": "auth_middleware"})
    exit(1)
```

### ‚ö†Ô∏è R√àGLES CRITIQUES POUR LES LOGS

1. **Format dictionnaire obligatoire** : Toujours utiliser `{"cl√©": str(valeur)[:limite]}`
2. **Limitation de caract√®res** : Maximum 100-500 caract√®res par valeur selon l'importance
3. **Exit apr√®s boucles** : Si log dans une boucle, exit imm√©diatement apr√®s pour √©viter le spam
4. **Cl√©s descriptives** : Utiliser des noms explicites (`user_id`, `db_status`, `validation_result`)

### Placement des exit()
- **Apr√®s validation d'hypoth√®se** : Confirmer que l'hypoth√®se est correcte
- **Avant action critique** : √âviter les effets de bord
- **Points de d√©cision** : Branches conditionnelles importantes
- **üö® PROTECTION CONTRE LES BOUCLES** : Exit imm√©diat apr√®s logs dans des boucles fr√©quentes
- **Arr√™t contr√¥l√©** : Permettre √† l'utilisateur d'effectuer des actions (ex: requ√™te web) puis r√©cup√©rer les logs

---

## √âtape 3 : Ex√©cution et R√©cup√©ration des Logs üöÄ

### Objectif
Lancer le programme dans les conditions propices au bug et r√©cup√©rer tous les logs.

### M√©thodes d'ex√©cution
1. **Ex√©cution directe** : `python main.py` ou `npm start`
2. **Script de debug temporaire** : Cr√©er `debug_test_scenario.py` √† la racine
3. **Conditions sp√©cifiques** : Reproduire l'environnement exact du bug

### R√®gles pour les scripts temporaires
- **Nommage** : Pr√©fixe `debug_` + description (ex: `debug_api_call.py`)
- **Localisation** : √Ä la racine du projet
- **Contenu** : Code minimal pour reproduire le bug
- **Authenticit√©** : Tester le v√©ritable code, pas une simulation

### Exemple de script temporaire
```python
# debug_api_call.py
import requests
import json

# Reproduire exactement les conditions du bug
headers = {"Authorization": "Bearer invalid_token"}
response = requests.get("http://localhost:3000/api/users", headers=headers)
print(f"Status: {response.status_code}")
print(f"Response: {response.text}")
```

### R√©cup√©ration des logs
- **Capturer TOUS les outputs** : stdout, stderr, fichiers de log
- **Pr√©server l'ordre** : Maintenir la chronologie des √©v√©nements
- **Contextualiser** : Noter les conditions d'ex√©cution

---

## √âtape 4 : Analyse des R√©sultats üîç

### Objectif
Analyser les logs r√©cup√©r√©s pour identifier les patterns et sympt√¥mes du bug.

### Crit√®res d'analyse
‚úÖ **Sympt√¥mes clairs** : Les logs montrent des valeurs inattendues ou des erreurs
‚ùå **Logs insuffisants** : Pas assez d'informations pour comprendre le probl√®me
‚ùå **Hypoth√®ses invalid√©es** : Aucune des hypoth√®ses n'est confirm√©e par les logs

### M√©thodologie d'analyse
1. **Examen des logs** : Identifier les valeurs inattendues ou les erreurs
2. **Corr√©lation avec les hypoth√®ses** : V√©rifier quelles hypoth√®ses sont valid√©es
3. **Identification des sympt√¥mes** : Comprendre ce qui ne fonctionne pas
4. **Pr√©paration du questionnement** : Pr√©parer les questions "POURQUOI" pour l'√©tape 4.a

### Exemple d'analyse
```markdown
**R√©sultats des logs** :
{
    "user_id": "None",
    "db_connected": "True", 
    "token_valid": "False",
    "validation_error": "silent_failure"
}

**Sympt√¥mes identifi√©s** :
- `user_id` est `None` alors qu'il devrait contenir un ID utilisateur
- `token_valid` est `False` mais aucune erreur n'est lev√©e
- La validation √©choue silencieusement

**Hypoth√®ses valid√©es** :
- ‚úÖ Hypoth√®se 1 : `user_id` est `None` (confirm√©e)
- ‚úÖ Hypoth√®se 3 : Validation token √©choue (confirm√©e)
```

---

## √âtape 4.a : Questionnement "POURQUOI" Obligatoire ‚ùì

### Objectif
Se poser la question "POURQUOI" pour chaque sympt√¥me identifi√© et r√©pondre avec certitude absolue.

### ‚ö†Ô∏è R√àGLE CRITIQUE
**Avant de passer √† l'√©tape 4.b, l'agent DOIT obligatoirement se poser la question "POURQUOI" pour chaque sympt√¥me et y r√©pondre avec certitude absolue.**

### Processus de questionnement "POURQUOI"
1. **Identifier le sympt√¥me** : "La variable X a la valeur Y"
2. **Poser la question** : "POURQUOI X a-t-elle la valeur Y ?"
3. **R√©pondre avec pr√©cision** : "Parce que la fonction Z ligne N fait W"
4. **Validation critique OBLIGATOIRE** : V√©rifier que tout est normal AVANT le passage probl√©matique
5. **Validation de la localisation** : Confirmer que le probl√®me appara√Æt BIEN juste apr√®s le passage identifi√©
6. **√âvaluer la certitude** : Suis-je s√ªr √† 100% d'avoir identifi√© l'UNIQUE passage probl√©matique ?

### Exemple de questionnement "POURQUOI"
```markdown
**Sympt√¥me identifi√©** : La liste `actions` est toujours vide
**Question POURQUOI** : POURQUOI la liste `actions` est-elle toujours vide ?

**R√©ponse initiale** : "Parce que la fonction `load_actions()` ligne 23 retourne toujours `[]`"

**Validation critique OBLIGATOIRE** :
- ‚úÖ Tout est normal AVANT ligne 23 : `user` existe, `user.is_active` est `True`
- ‚úÖ Le probl√®me appara√Æt BIEN juste apr√®s ligne 23 : `actions` devient `[]`
- ‚úÖ C'est l'UNIQUE passage probl√©matique : aucune autre fonction ne modifie `actions`

**R√©ponse finale** : "Parce que la fonction `load_actions()` ligne 23 retourne toujours `[]` car la condition `if user.is_active` ligne 25 est toujours `False`"

**√âvaluation** :
- ‚úÖ Cause claire + logique du code + certitude absolue ‚Üí Pr√™t pour √©tape 4.b
- ‚ùå Cause floue OU incertitude OU validation critique √©chou√©e ‚Üí Besoin de plus de logs (retour √©tape 2)
```

### Questions "POURQUOI" typiques
- **POURQUOI** cette variable a-t-elle cette valeur inattendue ?
- **POURQUOI** cette fonction retourne-t-elle ce r√©sultat incorrect ?
- **POURQUOI** cette condition est-elle toujours vraie/fausse ?
- **POURQUOI** cette exception n'est-elle pas catch√©e ?

### ‚ö†Ô∏è VALIDATION CRITIQUE OBLIGATOIRE

**L'agent DOIT √™tre extr√™mement prudent et v√©rifier** :

1. **√âtat normal AVANT le passage probl√©matique** :
   - Toutes les variables ont les valeurs attendues
   - Toutes les conditions sont dans l'√©tat normal
   - Aucun probl√®me n'existe avant la ligne identifi√©e

2. **Probl√®me appara√Æt BIEN juste apr√®s** :
   - Le sympt√¥me se manifeste imm√©diatement apr√®s le passage identifi√©
   - Pas de d√©lai ou d'autres √©tapes interm√©diaires
   - Lien direct et imm√©diat entre cause et effet

3. **UNIQUE passage probl√©matique** :
   - Aucune autre partie du code ne peut causer le m√™me probl√®me
   - Le passage identifi√© est la seule source possible du bug
   - Pas de causes multiples ou alternatives

**Si une seule de ces validations √©choue** ‚Üí Retour √† l'√©tape 2 pour plus de logs

---

## √âtape 4.b : D√©cision de Poursuite ou d'It√©ration üéØ

### Objectif
D√©cider si l'origine du bug est suffisamment claire pour passer au rapport final ou s'il faut continuer √† creuser.

### Crit√®res de d√©cision
‚úÖ **Origine clairement identifi√©e** : Question "POURQUOI" r√©solue avec certitude absolue ET validation critique r√©ussie
‚ùå **Origine floue** : Question "POURQUOI" sans r√©ponse claire ou avec incertitude
‚ùå **Cause superficielle** : Sympt√¥me identifi√© mais cause racine inconnue
‚ùå **Validation critique √©chou√©e** : √âtat normal non confirm√© OU probl√®me non localis√© pr√©cis√©ment

### D√©cisions possibles
- **Passage √† l'√©tape 5** : Origine clairement identifi√©e avec preuve absolue ET question "POURQUOI" r√©solue avec certitude ET validation critique r√©ussie
- **Retour √† l'√©tape 1.a** : Exploration insuffisante, besoin d'analyser plus de code
- **Retour √† l'√©tape 1.b** : Hypoth√®ses incorrectes ou trop superficielles
- **Retour √† l'√©tape 2** : Hypoth√®ses prometteuses mais logs insuffisants pour localiser pr√©cis√©ment OU question "POURQUOI" sans r√©ponse claire OU validation critique √©chou√©e

### ‚ö†Ô∏è R√àGLE CRITIQUE : Ne Pas Accepter de Solutions Approximatives
- **Preuve absolue requise** : Les logs doivent montrer EXACTEMENT quelle ligne cause le bug
- **Cause vs Cons√©quence** : Identifier la CAUSE racine, pas juste les sympt√¥mes
- **Localisation pr√©cise** : Savoir le fichier, la fonction ET la ligne exacte
- **It√©ration obligatoire** : Si le moindre doute subsiste, revenir aux √©tapes pr√©c√©dentes
- **Creuser jusqu'au bout** : Ne pas se satisfaire d'une explication qui "semble logique"

### Exemple de d√©cision
```markdown
**Question POURQUOI r√©solue** : "POURQUOI `user_id` est-il `None` ?"
**R√©ponse certaine** : "Parce que `extract_user_id_from_token()` ligne 15 retourne `None` car `token.payload['user_id']` n'existe pas"

**Validation critique OBLIGATOIRE** :
- ‚úÖ √âtat normal AVANT ligne 15 : `token` existe, `token.payload` existe
- ‚úÖ Probl√®me appara√Æt BIEN juste apr√®s ligne 15 : `user_id` devient `None`
- ‚úÖ UNIQUE passage probl√©matique : seule fonction qui extrait user_id du token

**√âvaluation finale** :
- ‚úÖ Cause claire : fonction sp√©cifique + ligne pr√©cise
- ‚úÖ Logique du code : payload manquant = user_id None
- ‚úÖ Certitude absolue : 100% s√ªr de cette explication
- ‚úÖ Validation critique : toutes les v√©rifications r√©ussies

**D√©cision** : ‚úÖ Passer √† l'√©tape 5 - origine clairement identifi√©e avec validation compl√®te
```

---

## √âtape 5 : Rapport Final üìã

### Objectif
Fournir un r√©sum√© d√©taill√© de l'origine du bug identifi√©.

### Rapport final obligatoire
Le rapport doit contenir :

#### R√©sum√© Ex√©cutif
- **Bug identifi√©** : Description claire du comportement probl√©matique
- **Origine pr√©cise** : Fichier, fonction, ligne exacte (si possible)
- **Cause racine** : Pourquoi le bug se produit

#### D√©tails Techniques
- **Hypoth√®ses test√©es** : Liste des hypoth√®ses valid√©es/invalid√©es
- **Logs d√©cisifs** : Les logs qui ont permis l'identification
- **Conditions de reproduction** : Environnement exact n√©cessaire

#### Recommandations
- **Priorit√© de correction** : Critique/Haute/Moyenne/Basse
- **Impact estim√©** : Utilisateurs affect√©s, fonctionnalit√©s impact√©es
- **Complexit√© de correction** : Estimation du temps n√©cessaire

### Exemple de rapport final
```markdown
## Rapport d'Enqu√™te : Bug d'Authentification API

### R√©sum√© Ex√©cutif
**Bug** : L'API retourne 200 OK m√™me avec des tokens invalides
**Origine** : `src/auth/token_validator.py:47` - fonction `validate_token()` retourne `True` par d√©faut
**Cause racine** : Logique de validation invers√©e dans la condition `if not token.is_valid()`

### D√©tails Techniques
**Hypoth√®ses test√©es** :
- ‚úÖ Hypoth√®se 1 : Token invalide accept√© (valid√©e)
- ‚ùå Hypoth√®se 2 : Probl√®me de connexion DB (invalid√©e)
- ‚ùå Hypoth√®se 3 : Middleware d√©faillant (invalid√©e)

**Logs d√©cisifs** :
```json
{
    "token_validation_result": "True",
    "token_is_valid": "False", 
    "validation_logic_error": "inverted_condition"
}
```

**Conditions de reproduction** : Token JWT expir√© ou malform√©

### Recommandations
**Priorit√©** : Critique (s√©curit√©)
**Impact** : Tous les utilisateurs avec tokens invalides
**Complexit√©** : Faible (1 ligne √† corriger)
```

---

## Exemples D√©taill√©s

### Exemple 1 : Bug dans une API Web üåê

**Contexte** : L'API retourne 500 au lieu de 401 pour les tokens invalides

#### √âtape 1.a : Exploration des fichiers
**Fichiers analys√©s** :
- `src/auth/middleware.py` : Middleware d'authentification (lignes 15-45)
- `src/auth/token_validator.py` : Validation JWT (lignes 20-80)
- `src/api/users.py` : Endpoint utilisateur (lignes 10-30)

**Flux identifi√©** :
Requ√™te ‚Üí middleware.auth() ‚Üí token_validator.verify() ‚Üí db.get_user() ‚Üí response

#### √âtape 1.b : Hypoth√®ses formul√©es
- Le middleware d'auth ne catch pas les exceptions dans `verify_signature()`
- La validation du token √©choue silencieusement dans `extract_user_id()`
- Le format du token est incorrect mais accept√© par `is_jwt_format()`
- La cl√© de signature est mauvaise dans `verify_signature()` ligne 47

#### √âtape 2 : Logs plac√©s
```python
# Dans le middleware d'auth - format dictionnaire avec limitation
print({
    "received_token": str(token[:20]) + "..." if len(token) > 20 else str(token),
    "token_format_valid": str(is_jwt_format(token))[:50],
    "token_signature_valid": str(verify_signature(token))[:50],
    "middleware_step": "token_validation"
})

# Exit strat√©gique apr√®s validation - CRITIQUE pour √©viter les boucles
if not verify_signature(token):
    print({
        "error": "Invalid signature detected",
        "location": "auth_middleware",
        "action": "stopping_execution"
    })
    exit(1)
```

#### √âtape 3 : Ex√©cution
```bash
python debug_api_test.py
# Logs r√©cup√©r√©s montrent le probl√®me
```

#### √âtape 4 : Analyse
Les logs montrent que la signature est invalide mais l'exception n'est pas catch√©e.

**Sympt√¥mes identifi√©s** :
- `token_signature_valid` est `False`
- Aucune exception n'est catch√©e
- Le programme continue et retourne 500

#### √âtape 4.a : Questionnement "POURQUOI"
**Question POURQUOI obligatoire** : POURQUOI l'exception n'est-elle pas catch√©e ?
**R√©ponse** : Parce que la fonction `verify_signature()` ligne 23 n'a pas de bloc try/catch autour de `jwt.decode()`, donc l'exception `InvalidSignatureError` remonte et cause le 500.

**Validation critique OBLIGATOIRE** :
- ‚úÖ √âtat normal AVANT ligne 23 : `token` existe, `jwt.decode()` est appel√© normalement
- ‚úÖ Probl√®me appara√Æt BIEN juste apr√®s ligne 23 : exception non catch√©e remonte
- ‚úÖ UNIQUE passage probl√©matique : seule fonction qui valide la signature

**√âvaluation** :
- ‚úÖ Cause claire : fonction sp√©cifique + ligne pr√©cise
- ‚úÖ Logique du code : pas de try/catch = exception non g√©r√©e
- ‚úÖ Certitude absolue : 100% s√ªr de cette explication
- ‚úÖ Validation critique : toutes les v√©rifications r√©ussies

#### √âtape 4.b : D√©cision
**D√©cision** : ‚úÖ Passer √† l'√©tape 5 - origine clairement identifi√©e

#### √âtape 5 : Rapport
**Origine pr√©cise identifi√©e** : Exception non g√©r√©e dans `verify_signature()` ligne 23 de `src/auth/token_validator.py`. **Cause racine** : Absence de try/catch autour de `jwt.decode()`.

### Exemple 2 : Bug de Logique M√©tier üíº

**Contexte** : Calcul de prix incorrect pour les commandes group√©es

#### √âtape 1.a : Exploration des fichiers
**Fichiers analys√©s** :
- `src/orders/calculator.py` : Calcul des prix (lignes 10-60)
- `src/orders/discount.py` : Logique de r√©duction (lignes 5-40)
- `src/orders/models.py` : Mod√®les de commande (lignes 20-80)

**Flux identifi√©** :
Commande ‚Üí calculate_order_total() ‚Üí get_discount_rate() ‚Üí calculate_final_total() ‚Üí prix final

#### √âtape 1.b : Hypoth√®ses formul√©es
- La r√©duction n'est pas appliqu√©e dans `calculate_final_total()` ligne 45
- Le calcul de quantit√© est erron√© dans `get_discount_rate()` ligne 12
- Les prix unitaires sont incorrects dans `extract_unit_prices()` ligne 28
- La logique de groupement √©choue dans `group_items_by_category()` ligne 15

#### √âtape 2 : Logs plac√©s
```python
# Dans calculate_order_total() - format dictionnaire avec limitation
print({
    "items_count": str(len(items))[:50],
    "unit_prices": str([item.price for item in items])[:200],
    "discount_rate": str(get_discount_rate(items))[:50],
    "subtotal": str(sum(item.price for item in items))[:100],
    "calculation_step": "before_final_total"
})

# Exit avant calcul final - CRITIQUE pour √©viter les boucles
total = calculate_final_total(subtotal, discount_rate)
print({
    "final_total": str(total)[:100],
    "calculation_complete": "true",
    "action": "stopping_for_analysis"
})
exit(1)
```

#### √âtape 3 : Ex√©cution
Script de test avec commande de 5 articles.

#### √âtape 4 : Analyse
Les logs montrent que `discount_rate` est 0 alors qu'il devrait √™tre 0.1.

**Sympt√¥mes identifi√©s** :
- `discount_rate` est `0` au lieu de `0.1`
- `items_count` est `5` (correct)
- Le calcul de r√©duction √©choue

#### √âtape 4.a : Questionnement "POURQUOI"
**Question POURQUOI obligatoire** : POURQUOI `discount_rate` est-il 0 au lieu de 0.1 ?
**R√©ponse** : Parce que la fonction `get_discount_rate()` ligne 12 v√©rifie `if len(items) >= 5` au lieu de `if sum(item.quantity for item in items) >= 5`, donc elle compte le nombre d'articles diff√©rents au lieu du nombre total d'articles.

**Validation critique OBLIGATOIRE** :
- ‚úÖ √âtat normal AVANT ligne 12 : `items` existe, contient 5 articles avec quantit√©s
- ‚úÖ Probl√®me appara√Æt BIEN juste apr√®s ligne 12 : `discount_rate` devient 0 au lieu de 0.1
- ‚úÖ UNIQUE passage probl√©matique : seule fonction qui calcule le taux de r√©duction

**√âvaluation** :
- ‚úÖ Cause claire : fonction sp√©cifique + ligne pr√©cise + logique incorrecte
- ‚úÖ Logique du code : len(items) vs sum(quantities) = bug √©vident
- ‚úÖ Certitude absolue : 100% s√ªr de cette explication
- ‚úÖ Validation critique : toutes les v√©rifications r√©ussies

#### √âtape 4.b : D√©cision
**D√©cision** : ‚úÖ Passer √† l'√©tape 5 - origine clairement identifi√©e

#### √âtape 5 : Rapport
**Origine pr√©cise identifi√©e** : Condition incorrecte dans `get_discount_rate()` ligne 12 de `src/orders/discount.py`. **Cause racine** : La condition v√©rifie `len(items) >= 5` au lieu de `sum(item.quantity for item in items) >= 5`.

---

## R√®gles de S√©curit√© et Bonnes Pratiques

### ‚ö†Ô∏è Interdictions Absolues
- **Ne jamais simuler** : Tester le v√©ritable code, pas une approximation
- **Ne jamais masquer** : Les logs doivent r√©v√©ler, pas cacher
- **Ne jamais contourner** : Identifier la cause, pas les sympt√¥mes
- **Ne jamais saturer la console** : Limiter les logs √† des dictionnaires avec caract√®res limit√©s
- **Ne jamais laisser des boucles sans exit** : Protection obligatoire contre les logs en boucle
- **Ne jamais passer √† l'√©tape 5 sans r√©pondre √† "POURQUOI"** : Question obligatoire avant le rapport final

### ‚úÖ Obligations
- **Logs clairs** : Format dictionnaire avec limitation de caract√®res obligatoire
- **Exit strat√©giques** : Protection contre les boucles infinies et contr√¥le de l'ex√©cution
- **Question "POURQUOI" obligatoire** : R√©pondre avec certitude avant l'√©tape 5
- **Rapport d√©taill√©** : Suffisamment pr√©cis pour permettre la correction

### üîÑ It√©rations et Approfondissement
- **It√©ration obligatoire** : Si le moindre doute subsiste, revenir aux √©tapes pr√©c√©dentes
- **Creuser en profondeur** : Ne pas accepter la premi√®re explication qui semble logique
- **Preuve absolue requise** : Identifier la CAUSE racine, pas les sympt√¥mes
- **Localisation pr√©cise** : Savoir le fichier, la fonction ET la ligne exacte
- **Tra√ßabilit√©** : Garder une trace de toutes les hypoth√®ses test√©es et des r√©sultats

---

## Activation de la R√®gle

Cette r√®gle est activ√©e manuellement par l'utilisateur lors de sessions de d√©bogage. Pour l'utiliser :

1. **D√©clencher** : "Utilise la r√®gle enqu√™teur pour identifier l'origine de ce bug"
2. **Contextualiser** : Fournir la description du bug et les conditions de reproduction
3. **Suivre** : L'agent suivra automatiquement le processus en 5 √©tapes
4. **Valider** : V√©rifier que le repo est propre apr√®s l'enqu√™te

**Rappel** : Cette r√®gle identifie, ne corrige pas. Une fois l'origine claire, c'est √† l'utilisateur ou √† une autre r√®gle de proc√©der √† la correction.