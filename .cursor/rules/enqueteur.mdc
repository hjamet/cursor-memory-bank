---
alwaysApply: false
description: Guide m√©thodologique pour identifier syst√©matiquement l'origine pr√©cise d'un bug via hypoth√®ses, logs de d√©bogage et analyse
---

# R√®gle Enqu√™teur : Identification Syst√©matique des Bugs üïµÔ∏è

## Principe Fondamental : Fail-Fast Appliqu√© au D√©bogage

Cette r√®gle impl√©mente le principe "Fail-Fast" dans le contexte du d√©bogage : **identifier rapidement et pr√©cis√©ment l'origine du bug sans le masquer**. L'objectif n'est PAS de r√©soudre le bug, mais de le localiser avec une pr√©cision chirurgicale pour permettre une correction cibl√©e.

**Philosophie** : Un bug mal localis√© est un bug qui reviendra. Mieux vaut √©chouer rapidement avec une origine claire qu'un contournement qui masque la cause racine.

## Processus M√©thodologique en 5 √âtapes

### ‚ö†Ô∏è R√àGLE CRITIQUE : Indication Obligatoire de l'√âtape

L'agent DOIT **toujours** indiquer son √©tape actuelle avec des titres markdown explicites :
- `## √âtape 1.a : Exploration des fichiers de code`
- `## √âtape 1.b : Formulation d'hypoth√®ses`
- `## √âtape 2 : Placement de logs de d√©bogage`
- `## √âtape 3 : Ex√©cution et r√©cup√©ration des logs`
- `## √âtape 4 : Analyse des r√©sultats`
- `## √âtape 5 : Nettoyage et rapport final`

---

## √âtape 1.a : Exploration des Fichiers de Code üîç

### Objectif
Analyser en profondeur le code pour comprendre le contexte, les flux d'ex√©cution et identifier tous les points de d√©faillance potentiels.

### M√©thodologie d'exploration
1. **Cartographie du code** : Identifier tous les fichiers impliqu√©s dans le bug
2. **Analyse des flux** : Comprendre le parcours d'ex√©cution complet
3. **Identification des d√©pendances** : Variables, fonctions, services externes
4. **Points critiques** : Conditions, validations, transformations de donn√©es
5. **Contexte d'ex√©cution** : Environnement, configuration, √©tat initial

### Outils d'exploration
- **Recherche s√©mantique** : `codebase_search` pour comprendre les fonctionnalit√©s
- **Analyse de fichiers** : `read_file` pour examiner le code source
- **Recherche de patterns** : `grep` pour trouver des motifs sp√©cifiques
- **Navigation** : `list_dir` pour comprendre la structure

### Exemple d'exploration
```markdown
**Fichiers identifi√©s** :
- `src/auth/middleware.py` : Middleware d'authentification
- `src/auth/token_validator.py` : Validation des tokens JWT
- `src/database/connection.py` : Gestion des connexions DB
- `src/api/users.py` : Endpoint utilisateur

**Flux d'ex√©cution** :
1. Requ√™te HTTP ‚Üí Middleware auth ‚Üí Validation token ‚Üí DB query ‚Üí Response
2. Points critiques : validation token, extraction user_id, requ√™te DB

**D√©pendances identifi√©es** :
- Variable `user_id` extraite du token
- Fonction `verify_signature()` pour validation
- Connexion DB pour requ√™te utilisateur
```

---

## √âtape 1.b : Formulation d'Hypoth√®ses üéØ

### Objectif
Formuler 3-5 hypoth√®ses pr√©cises sur l'origine probable du bug, bas√©es sur l'exploration approfondie du code.

### M√©thodologie
1. **Synth√®se de l'exploration** : Utiliser les informations collect√©es √† l'√©tape 1.a
2. **Identification des points de d√©faillance** : Variables, fonctions, conditions, flux d'ex√©cution
3. **Priorisation** : Classer les hypoth√®ses par probabilit√© et impact
4. **Formulation claire** : Chaque hypoth√®se doit √™tre testable et sp√©cifique
5. **Approfondissement** : Ne pas se satisfaire d'hypoth√®ses superficielles

### Exemple de formulation
```markdown
**Hypoth√®se 1** : La variable `user_id` est `None` lors de l'appel √† `get_user_profile()` car `extract_user_id_from_token()` √©choue silencieusement
**Hypoth√®se 2** : La connexion √† la base de donn√©es √©choue silencieusement dans `db.get_user(user_id)`
**Hypoth√®se 3** : Le middleware d'authentification ne valide pas correctement le token dans `verify_signature()`
**Hypoth√®se 4** : La fonction `validate_input()` retourne `True` pour des donn√©es invalides dans `sanitize_user_data()`
**Hypoth√®se 5** : Race condition entre deux processus acc√©dant √† la m√™me ressource dans `update_user_cache()`
```

### ‚ö†Ô∏è R√àGLE CRITIQUE : Ne Pas Se Satisfaire de Solutions Simples
- **Creuser en profondeur** : Ne pas accepter la premi√®re explication qui semble logique
- **It√©rer si n√©cessaire** : Revenir aux √©tapes 1.a ou 1.b si le moindre doute subsiste
- **Preuve absolue** : Identifier la CAUSE, pas la cons√©quence
- **Localisation pr√©cise** : Savoir exactement quelle ligne cause le probl√®me

---

## √âtape 2 : Placement de Logs de D√©bogage üìù

### Objectif
Ins√©rer des logs standards (sans marqueur sp√©cial) et des `exit()` strat√©giques pour valider chaque hypoth√®se.

### R√®gles de placement
- **Logs informatifs** : Dictionnaires de variables avec formatage contr√¥l√© et limitation de caract√®res
- **Exit strat√©giques** : Arr√™t du programme juste apr√®s les points de validation cl√©s - **CRITIQUE pour √©viter les boucles infinies**
- **Pas de marqueurs** : Utiliser des logs standards pour faciliter le nettoyage
- **Granularit√© progressive** : Commencer large, puis affiner selon les r√©sultats
- **Protection contre les boucles** : Exit obligatoire apr√®s logs dans des boucles fr√©quentes

### Format standard des logs
```python
# Format recommand√© : dictionnaire avec limitation de caract√®res
print({
    "user_id": str(user_id)[:100],
    "db_connected": str(db.is_connected())[:50],
    "token_valid": str(validate_token(token))[:50],
    "request_headers": str(request.headers)[:200]
})

# Exit strat√©gique apr√®s validation - OBLIGATOIRE pour √©viter les boucles
if user_id is None:
    print({"error": "user_id is None", "location": "auth_middleware"})
    exit(1)
```

### ‚ö†Ô∏è R√àGLES CRITIQUES POUR LES LOGS

1. **Format dictionnaire obligatoire** : Toujours utiliser `{"cl√©": str(valeur)[:limite]}`
2. **Limitation de caract√®res** : Maximum 100-500 caract√®res par valeur selon l'importance
3. **Exit apr√®s boucles** : Si log dans une boucle, exit imm√©diatement apr√®s pour √©viter le spam
4. **Cl√©s descriptives** : Utiliser des noms explicites (`user_id`, `db_status`, `validation_result`)

### Placement des exit()
- **Apr√®s validation d'hypoth√®se** : Confirmer que l'hypoth√®se est correcte
- **Avant action critique** : √âviter les effets de bord
- **Points de d√©cision** : Branches conditionnelles importantes
- **üö® PROTECTION CONTRE LES BOUCLES** : Exit imm√©diat apr√®s logs dans des boucles fr√©quentes
- **Arr√™t contr√¥l√©** : Permettre √† l'utilisateur d'effectuer des actions (ex: requ√™te web) puis r√©cup√©rer les logs

---

## √âtape 3 : Ex√©cution et R√©cup√©ration des Logs üöÄ

### Objectif
Lancer le programme dans les conditions propices au bug et r√©cup√©rer tous les logs.

### M√©thodes d'ex√©cution
1. **Ex√©cution directe** : `python main.py` ou `npm start`
2. **Script de debug temporaire** : Cr√©er `debug_test_scenario.py` √† la racine
3. **Conditions sp√©cifiques** : Reproduire l'environnement exact du bug

### R√®gles pour les scripts temporaires
- **Nommage** : Pr√©fixe `debug_` + description (ex: `debug_api_call.py`)
- **Localisation** : √Ä la racine du projet
- **Contenu** : Code minimal pour reproduire le bug
- **Authenticit√©** : Tester le v√©ritable code, pas une simulation

### Exemple de script temporaire
```python
# debug_api_call.py
import requests
import json

# Reproduire exactement les conditions du bug
headers = {"Authorization": "Bearer invalid_token"}
response = requests.get("http://localhost:3000/api/users", headers=headers)
print(f"Status: {response.status_code}")
print(f"Response: {response.text}")
```

### R√©cup√©ration des logs
- **Capturer TOUS les outputs** : stdout, stderr, fichiers de log
- **Pr√©server l'ordre** : Maintenir la chronologie des √©v√©nements
- **Contextualiser** : Noter les conditions d'ex√©cution

---

## √âtape 4 : Analyse des R√©sultats üîç

### Objectif
D√©cider si les logs permettent d'identifier CLAIREMENT l'origine du bug.

### Crit√®res de validation
‚úÖ **Origine clairement identifi√©e** : Les logs montrent exactement o√π et pourquoi le bug se produit
‚ùå **Origine floue** : Les logs indiquent un probl√®me mais pas sa cause pr√©cise
‚ùå **Hypoth√®ses incorrectes** : Aucune des hypoth√®ses n'est valid√©e

### ‚ö†Ô∏è QUESTION OBLIGATOIRE AVANT L'√âTAPE 5 : "POURQUOI ?"

**R√àGLE CRITIQUE** : Avant de passer √† l'√©tape 5, l'agent DOIT obligatoirement se poser la question "POURQUOI" et y r√©pondre avec certitude absolue.

#### Exemple de questionnement "POURQUOI"
```markdown
**Probl√®me identifi√©** : La liste `actions` est toujours vide
**Question POURQUOI** : POURQUOI la liste `actions` est-elle toujours vide ?

**R√©ponses possibles** :
‚úÖ **Cause claire** : "Parce que la fonction `load_actions()` ligne 23 retourne toujours `[]` car la condition `if user.is_active` ligne 25 est toujours `False`"
‚ùå **Cause floue** : "Parce que la fonction `load_actions()` ne fonctionne pas correctement"

**D√©cision** :
- ‚úÖ Si la cause est claire et logique ‚Üí Passer √† l'√©tape 5
- ‚ùå Si la cause est floue ou inconnue ‚Üí Continuer √† creuser (√©tape 2)
```

#### Processus de validation "POURQUOI"
1. **Identifier le sympt√¥me** : "La variable X a la valeur Y"
2. **Poser la question** : "POURQUOI X a-t-elle la valeur Y ?"
3. **R√©pondre avec pr√©cision** : "Parce que la fonction Z ligne N fait W"
4. **Valider la logique** : Cette explication s'inscrit-elle dans la logique du code ?
5. **D√©cider** : Cause claire ‚Üí √âtape 5, Cause floue ‚Üí Continuer √©tape 2

### D√©cisions possibles
- **Passage √† l'√©tape 5** : Origine clairement identifi√©e avec preuve absolue ET question "POURQUOI" r√©solue avec certitude
- **Retour √† l'√©tape 1.a** : Exploration insuffisante, besoin d'analyser plus de code
- **Retour √† l'√©tape 1.b** : Hypoth√®ses incorrectes ou trop superficielles
- **Retour √† l'√©tape 2** : Hypoth√®ses prometteuses mais logs insuffisants pour localiser pr√©cis√©ment OU question "POURQUOI" sans r√©ponse claire

### ‚ö†Ô∏è R√àGLE CRITIQUE : Ne Pas Accepter de Solutions Approximatives
- **Preuve absolue requise** : Les logs doivent montrer EXACTEMENT quelle ligne cause le bug
- **Cause vs Cons√©quence** : Identifier la CAUSE racine, pas juste les sympt√¥mes
- **Localisation pr√©cise** : Savoir le fichier, la fonction ET la ligne exacte
- **It√©ration obligatoire** : Si le moindre doute subsiste, revenir aux √©tapes pr√©c√©dentes
- **Creuser jusqu'au bout** : Ne pas se satisfaire d'une explication qui "semble logique"

### Exemple d'analyse
```markdown
**R√©sultats des logs** :
{
    "user_id": "None",
    "db_connected": "True", 
    "token_valid": "False",
    "validation_error": "silent_failure"
}

**Conclusion** : L'origine est clairement identifi√©e : `user_id` est `None` 
car le token est invalide, mais la validation √©choue silencieusement.
Le bug se situe dans la fonction `extract_user_id_from_token()`.
```

---

## √âtape 5 : Nettoyage et Rapport Final üßπ

### Objectif
Supprimer tous les ajouts temporaires et fournir un r√©sum√© d√©taill√© de l'origine du bug.

### Nettoyage obligatoire
1. **Supprimer tous les logs** ajout√©s lors de l'√©tape 2
2. **Supprimer tous les scripts** `debug_*.py` cr√©√©s
3. **Supprimer tous les exit()** temporaires
4. **V√©rifier la propret√©** : `git status` doit √™tre clean

### V√©rification de propret√©
```bash
git status
# Doit afficher : "nothing to commit, working tree clean"
```

### Rapport final obligatoire
Le rapport doit contenir :

#### R√©sum√© Ex√©cutif
- **Bug identifi√©** : Description claire du comportement probl√©matique
- **Origine pr√©cise** : Fichier, fonction, ligne exacte (si possible)
- **Cause racine** : Pourquoi le bug se produit

#### D√©tails Techniques
- **Hypoth√®ses test√©es** : Liste des hypoth√®ses valid√©es/invalid√©es
- **Logs d√©cisifs** : Les logs qui ont permis l'identification
- **Conditions de reproduction** : Environnement exact n√©cessaire

#### Recommandations
- **Priorit√© de correction** : Critique/Haute/Moyenne/Basse
- **Impact estim√©** : Utilisateurs affect√©s, fonctionnalit√©s impact√©es
- **Complexit√© de correction** : Estimation du temps n√©cessaire

### Exemple de rapport final
```markdown
## Rapport d'Enqu√™te : Bug d'Authentification API

### R√©sum√© Ex√©cutif
**Bug** : L'API retourne 200 OK m√™me avec des tokens invalides
**Origine** : `src/auth/token_validator.py:47` - fonction `validate_token()` retourne `True` par d√©faut
**Cause racine** : Logique de validation invers√©e dans la condition `if not token.is_valid()`

### D√©tails Techniques
**Hypoth√®ses test√©es** :
- ‚úÖ Hypoth√®se 1 : Token invalide accept√© (valid√©e)
- ‚ùå Hypoth√®se 2 : Probl√®me de connexion DB (invalid√©e)
- ‚ùå Hypoth√®se 3 : Middleware d√©faillant (invalid√©e)

**Logs d√©cisifs** :
```json
{
    "token_validation_result": "True",
    "token_is_valid": "False", 
    "validation_logic_error": "inverted_condition"
}
```

**Conditions de reproduction** : Token JWT expir√© ou malform√©

### Recommandations
**Priorit√©** : Critique (s√©curit√©)
**Impact** : Tous les utilisateurs avec tokens invalides
**Complexit√©** : Faible (1 ligne √† corriger)
```

---

## Exemples D√©taill√©s

### Exemple 1 : Bug dans une API Web üåê

**Contexte** : L'API retourne 500 au lieu de 401 pour les tokens invalides

#### √âtape 1.a : Exploration des fichiers
**Fichiers analys√©s** :
- `src/auth/middleware.py` : Middleware d'authentification (lignes 15-45)
- `src/auth/token_validator.py` : Validation JWT (lignes 20-80)
- `src/api/users.py` : Endpoint utilisateur (lignes 10-30)

**Flux identifi√©** :
Requ√™te ‚Üí middleware.auth() ‚Üí token_validator.verify() ‚Üí db.get_user() ‚Üí response

#### √âtape 1.b : Hypoth√®ses formul√©es
- Le middleware d'auth ne catch pas les exceptions dans `verify_signature()`
- La validation du token √©choue silencieusement dans `extract_user_id()`
- Le format du token est incorrect mais accept√© par `is_jwt_format()`
- La cl√© de signature est mauvaise dans `verify_signature()` ligne 47

#### √âtape 2 : Logs plac√©s
```python
# Dans le middleware d'auth - format dictionnaire avec limitation
print({
    "received_token": str(token[:20]) + "..." if len(token) > 20 else str(token),
    "token_format_valid": str(is_jwt_format(token))[:50],
    "token_signature_valid": str(verify_signature(token))[:50],
    "middleware_step": "token_validation"
})

# Exit strat√©gique apr√®s validation - CRITIQUE pour √©viter les boucles
if not verify_signature(token):
    print({
        "error": "Invalid signature detected",
        "location": "auth_middleware",
        "action": "stopping_execution"
    })
    exit(1)
```

#### √âtape 3 : Ex√©cution
```bash
python debug_api_test.py
# Logs r√©cup√©r√©s montrent le probl√®me
```

#### √âtape 4 : Analyse
Les logs montrent que la signature est invalide mais l'exception n'est pas catch√©e. 

**Question POURQUOI obligatoire** : POURQUOI l'exception n'est-elle pas catch√©e ?
**R√©ponse** : Parce que la fonction `verify_signature()` ligne 23 n'a pas de bloc try/catch autour de `jwt.decode()`, donc l'exception `InvalidSignatureError` remonte et cause le 500.

**Preuve absolue** : Le bug se situe exactement ligne 23 de `src/auth/token_validator.py` dans la fonction `verify_signature()` o√π l'exception `InvalidSignatureError` n'est pas g√©r√©e.

#### √âtape 5 : Rapport
**Origine pr√©cise identifi√©e** : Exception non g√©r√©e dans `verify_signature()` ligne 23 de `src/auth/token_validator.py`. **Cause racine** : Absence de try/catch autour de `jwt.decode()`.

### Exemple 2 : Bug de Logique M√©tier üíº

**Contexte** : Calcul de prix incorrect pour les commandes group√©es

#### √âtape 1.a : Exploration des fichiers
**Fichiers analys√©s** :
- `src/orders/calculator.py` : Calcul des prix (lignes 10-60)
- `src/orders/discount.py` : Logique de r√©duction (lignes 5-40)
- `src/orders/models.py` : Mod√®les de commande (lignes 20-80)

**Flux identifi√©** :
Commande ‚Üí calculate_order_total() ‚Üí get_discount_rate() ‚Üí calculate_final_total() ‚Üí prix final

#### √âtape 1.b : Hypoth√®ses formul√©es
- La r√©duction n'est pas appliqu√©e dans `calculate_final_total()` ligne 45
- Le calcul de quantit√© est erron√© dans `get_discount_rate()` ligne 12
- Les prix unitaires sont incorrects dans `extract_unit_prices()` ligne 28
- La logique de groupement √©choue dans `group_items_by_category()` ligne 15

#### √âtape 2 : Logs plac√©s
```python
# Dans calculate_order_total() - format dictionnaire avec limitation
print({
    "items_count": str(len(items))[:50],
    "unit_prices": str([item.price for item in items])[:200],
    "discount_rate": str(get_discount_rate(items))[:50],
    "subtotal": str(sum(item.price for item in items))[:100],
    "calculation_step": "before_final_total"
})

# Exit avant calcul final - CRITIQUE pour √©viter les boucles
total = calculate_final_total(subtotal, discount_rate)
print({
    "final_total": str(total)[:100],
    "calculation_complete": "true",
    "action": "stopping_for_analysis"
})
exit(1)
```

#### √âtape 3 : Ex√©cution
Script de test avec commande de 5 articles.

#### √âtape 4 : Analyse
Les logs montrent que `discount_rate` est 0 alors qu'il devrait √™tre 0.1.

**Question POURQUOI obligatoire** : POURQUOI `discount_rate` est-il 0 au lieu de 0.1 ?
**R√©ponse** : Parce que la fonction `get_discount_rate()` ligne 12 v√©rifie `if len(items) >= 5` au lieu de `if sum(item.quantity for item in items) >= 5`, donc elle compte le nombre d'articles diff√©rents au lieu du nombre total d'articles.

**Preuve absolue** : Le bug se situe exactement ligne 12 de `src/orders/discount.py` dans la fonction `get_discount_rate()` o√π la condition `if len(items) >= 5` est incorrecte.

#### √âtape 5 : Rapport
**Origine pr√©cise identifi√©e** : Condition incorrecte dans `get_discount_rate()` ligne 12 de `src/orders/discount.py`. **Cause racine** : La condition v√©rifie `len(items) >= 5` au lieu de `sum(item.quantity for item in items) >= 5`.

---

## R√®gles de S√©curit√© et Bonnes Pratiques

### ‚ö†Ô∏è Interdictions Absolues
- **Ne jamais simuler** : Tester le v√©ritable code, pas une approximation
- **Ne jamais masquer** : Les logs doivent r√©v√©ler, pas cacher
- **Ne jamais contourner** : Identifier la cause, pas les sympt√¥mes
- **Ne jamais saturer la console** : Limiter les logs √† des dictionnaires avec caract√®res limit√©s
- **Ne jamais laisser des boucles sans exit** : Protection obligatoire contre les logs en boucle
- **Ne jamais passer √† l'√©tape 5 sans r√©pondre √† "POURQUOI"** : Question obligatoire avant le rapport final

### ‚úÖ Obligations
- **Nettoyage complet** : Le repo doit √™tre identique √† l'√©tat initial
- **Logs clairs** : Format dictionnaire avec limitation de caract√®res obligatoire
- **Exit strat√©giques** : Protection contre les boucles infinies et contr√¥le de l'ex√©cution
- **Question "POURQUOI" obligatoire** : R√©pondre avec certitude avant l'√©tape 5
- **Rapport d√©taill√©** : Suffisamment pr√©cis pour permettre la correction

### üîÑ It√©rations et Approfondissement
- **It√©ration obligatoire** : Si le moindre doute subsiste, revenir aux √©tapes pr√©c√©dentes
- **Creuser en profondeur** : Ne pas accepter la premi√®re explication qui semble logique
- **Preuve absolue requise** : Identifier la CAUSE racine, pas les sympt√¥mes
- **Localisation pr√©cise** : Savoir le fichier, la fonction ET la ligne exacte
- **Tra√ßabilit√©** : Garder une trace de toutes les hypoth√®ses test√©es et des r√©sultats

---

## Activation de la R√®gle

Cette r√®gle est activ√©e manuellement par l'utilisateur lors de sessions de d√©bogage. Pour l'utiliser :

1. **D√©clencher** : "Utilise la r√®gle enqu√™teur pour identifier l'origine de ce bug"
2. **Contextualiser** : Fournir la description du bug et les conditions de reproduction
3. **Suivre** : L'agent suivra automatiquement le processus en 5 √©tapes
4. **Valider** : V√©rifier que le repo est propre apr√®s l'enqu√™te

**Rappel** : Cette r√®gle identifie, ne corrige pas. Une fois l'origine claire, c'est √† l'utilisateur ou √† une autre r√®gle de proc√©der √† la correction.