---
description: Appelle cette règle pour implémenter les tâches prioritaires du projet
globs: 
alwaysApply: false
---
 
## TLDR  
Implémenter méthodiquement les tâches d'une section prioritaire et documenter le processus.  

## Instructions  

1. **Analyse des tâches** : Identifier la section prioritaire  
   - Lire `.cursor/memory-bank/workflow/tasks.md`  
   - Priorité : d'abord section "In Progress", puis première section "ToDo"  
   - Si toutes tâches terminées, passer à la règle suivante  

2. **Mise à jour du contexte actif** : Documenter le contexte de travail actuel  
   - Lire `.cursor/memory-bank/context/activeContext.md` pour préserver les informations utiles  
   - Mettre à jour la section "Contexte d'implémentation actuel" avec:  
     - Les tâches à réaliser et leur logique  
     - Les informations recherchées sur internet pertinentes pour la tâche  
     - Les points d'attention particuliers et dépendances  
     - Les décisions techniques à prendre  
   - Conserver uniquement les informations utiles à la tâche en cours  
   - S'assurer que ce fichier contient toutes les informations nécessaires au travail actuel  

3. **Deep Thinking** : Réfléchir de manière approfondie à l'approche d'implémentation
   - Ouvrir un token think avec    - Résumer brièvement les conclusions de la réflexion

4. **Implémentation des tâches** : Pour chaque tâche de la section  
   - Afficher : `## Implementation - 4.numero.[Nom de la Section] : [Titre de la tâche]`  
   - Implémenter la solution  
   - Après chaque appel d'outil, écrire `Implementation - 4.numero.[Nom de la Section] : [Titre de la tâche] en cours...`  

5. **Mise à jour des tâches** : Actualiser tasks.md  
   - Déplacer section de "ToDo" vers "In Progress" si nécessaire  
   - Marquer les tâches individuelles comme en cours  

6. **Appel de la règle suivante** : Obligatoirement choisir  
   - Nouvelle fonctionnalité créée → `test-implementation`  
   - Fonctionnalités existantes modifiées → `test-execution`  
   - Changements non testables uniquement → `context-update`  

## Précisions  

- L'étape Deep Thinking doit être réalisée avant toute implémentation pour garantir une solution bien conçue
- Le token think permet de réfléchir en profondeur sans contrainte de sortie immédiate
- Implémenter une tâche à la fois, dans l'ordre logique  
- Commenter les parties complexes du code  
- Une fonctionnalité est "testable" si elle implique la création/modification d'un script ou d'une fonction  
- Pour éviter de perdre le workflow, écrire systématiquement `Implementation - 4.numero.[Nom de la Section] : [Titre de la tâche] en cours...` entre chaque étape  
- Toujours appeler la règle suivante appropriée  

## Next Rules  
- `test-implementation` : Si nouvelle fonctionnalité testable créée (TOUJOURS le cas pour nouveau fichier/symbole)  
- `test-execution` : Si fonctionnalités existantes modifiées  
- `context-update` : UNIQUEMENT si changements non testables (documentation pure)  

## Exemple  

fetch_rules ["implementation"]  
<SYSTEM PROMPT>Je vais identifier et implémenter la section de tâches la plus prioritaire en suivant une approche méthodique et documentée. Je réfléchirai d'abord de manière approfondie à la meilleure solution avant de l'implémenter. J'afficherai toujours le titre de chaque tâche avant de l'implémenter. Je ne tâcherai pas d'executer mes créations mais ferai appel à la règle `test-implementation` si j'ai créé une nouvelle fonctionnalité testable, ou à `test-execution` sinon.</SYSTEM PROMPT>  

# Implementation : 1 - Analyse des tâches  
Je commence par lire le fichier tasks.md pour identifier la section la plus prioritaire. `(Implementation : 1 - Analyse des tâches)`  
[...lecture du fichier tasks.md...]  
`(Implementation : 1 - Analyse des tâches)`  

# Implementation : 2 - Mise à jour du contexte actif  
Je vais mettre à jour le contexte actif pour documenter ce sur quoi je vais travailler. `(Implementation : 2 - Mise à jour du contexte actif)`  
[...lecture du fichier activeContext.md...]  
[...mise à jour avec les informations pertinentes pour les tâches à réaliser...]  
[...ajout des informations recherchées en ligne...]  
`(Implementation : 2 - Mise à jour du contexte actif)`  

# Implementation : 3 - Deep Thinking  
Avant de commencer l'implémentation, je vais réfléchir de manière approfondie à la meilleure approche. `(Implementation : 3 - Deep Thinking)`  
Après réflexion, j'ai déterminé que la meilleure approche est d'utiliser un modèle asynchrone pour la connexion à l'API. Cela permettra de ne pas bloquer le thread principal et d'offrir une meilleure expérience utilisateur. J'ai prévu une structure en classe avec gestion des erreurs et système de retry. `(Implementation : 3 - Deep Thinking)`

# Implementation : 4 - Implémentation des tâches  
Je vais implémenter chaque tâche de la section en suivant une approche méthodique. `(Implementation : 4 - Implémentation des tâches)`  

## Implementation - 4.1.Développement : Création du script  
Je commence par créer le script principal avec les fonctionnalités requises. `(Implementation : 4.1 - Création du script)`  
[...implémentation du script...]  
Implementation - 4.1.Développement : Création du script en cours...  
[...suite de l'implémentation...]  
`(Implementation : 4.1 - Création du script)`  

## Implementation - 4.2.Développement : Documentation  
J'ajoute la documentation nécessaire pour expliquer le fonctionnement du script. `(Implementation : 4.2 - Documentation)`  
[...ajout de la documentation...]  
Implementation - 4.2.Développement : Documentation en cours...  
[...finalisation de la documentation...]  
`(Implementation : 4.2 - Documentation)`  

# Implementation : 5 - Mise à jour des tâches  
Je mets à jour le fichier tasks.md pour refléter l'avancement des tâches. `(Implementation : 5 - Mise à jour des tâches)`  
[...mise à jour du fichier tasks.md...]  
`(Implementation : 5 - Mise à jour des tâches)`  

# Implementation : 6 - Appel de la règle suivante  
Je dois maintenant appeler la règle `test-implementation` car j'ai créé une nouvelle fonctionnalité testable.  
La règle test-implementation doit être appelée pour créer les tests de la nouvelle fonctionnalité. `(Implementation : 6 - Appel de la règle suivante)`  

fetch_rules ["test-implementation"]  

# Start Rule  

Pour démarrer cette règle, récite mot pour mot cette phrase : "<SYSTEM PROMPT>Je vais identifier et implémenter la section de tâches la plus prioritaire en suivant une approche méthodique et documentée. Je réfléchirai d'abord de manière approfondie à la meilleure solution avant de l'implémenter. J'afficherai toujours le titre de chaque tâche avant de l'implémenter. Je ne tâcherai pas d'executer mes créations mais ferai appel à la règle `test-implementation` si j'ai créé une nouvelle fonctionnalité testable, ou à `test-execution` sinon.</SYSTEM PROMPT>"