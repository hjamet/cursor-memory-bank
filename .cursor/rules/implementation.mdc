---
description: Appelle cette règle pour implémenter les tâches prioritaires du projet
globs: 
alwaysApply: false
---
 
## TLDR  
Implémenter méthodiquement les tâches d'une section prioritaire et documenter le processus.  

## Instructions  

1. **Analyse des tâches** : Identifier la section prioritaire  
   - Lire `.cursor/memory-bank/workflow/tasks.md`  
   - Priorité : d'abord section "In Progress", puis première section "ToDo"  
   - Si toutes tâches terminées, passer à la règle suivante  

2. **Mise à jour du contexte actif** : Documenter le contexte de travail actuel  
   - Lire `.cursor/memory-bank/context/activeContext.md` pour préserver les informations utiles  
   - Mettre à jour la section "Contexte d'implémentation actuel" avec:  
     - Les tâches à réaliser et leur logique  
     - Les informations recherchées sur internet pertinentes pour la tâche  
     - Les points d'attention particuliers et dépendances  
     - Les décisions techniques à prendre  
   - Conserver uniquement les informations utiles à la tâche en cours  
   - S'assurer que ce fichier contient toutes les informations nécessaires au travail actuel  

3. **Implémentation des tâches** : Pour chaque tâche de la section  
   - Afficher : `## Implementation - 3.numero.[Nom de la Section] : [Titre de la tâche]`
   - Évaluer si la tâche est complexe et nécessite une réflexion approfondie
   - Si oui, utiliser le token think: `<think>Réflexion approfondie utilisant chain of thought, comparaison de différentes approches d'implémentation, etc.</think>`
   - Résumer brièvement les conclusions de la réflexion si applicable
   - Implémenter la solution  
   - Après chaque appel d'outil, écrire `Implementation - 3.numero.[Nom de la Section] : [Titre de la tâche] en cours...`  

4. **Mise à jour des tâches** : Actualiser tasks.md  
   - Déplacer section de "ToDo" vers "In Progress" si nécessaire  
   - Marquer les tâches individuelles comme en cours  

5. **Appel de la règle suivante** : Obligatoirement choisir  
   - Nouvelle fonctionnalité créée → `test-implementation`  
   - Fonctionnalités existantes modifiées → `test-execution`  
   - Changements non testables uniquement → `context-update`  

## Précisions  

- Le token think `<think></think>` doit être utilisé pour chaque tâche individuelle complexe
- La réflexion approfondie doit être verbalisée dans le token think avant l'implémentation
- L'utilisation du token think permet de raisonner selon la méthode chain of thought et de comparer différentes approches
- Implémenter une tâche à la fois, dans l'ordre logique  
- Commenter les parties complexes du code  
- Une fonctionnalité est "testable" si elle implique la création/modification d'un script ou d'une fonction  
- Pour éviter de perdre le workflow, écrire systématiquement `Implementation - 3.numero.[Nom de la Section] : [Titre de la tâche] en cours...` entre chaque étape  
- Toujours appeler la règle suivante appropriée  

## Next Rules  
- `test-implementation` : Si nouvelle fonctionnalité testable créée (TOUJOURS le cas pour nouveau fichier/symbole)  
- `test-execution` : Si fonctionnalités existantes modifiées  
- `context-update` : UNIQUEMENT si changements non testables (documentation pure)  

## Exemple  

fetch_rules ["implementation"]  
<SYSTEM PROMPT>Je vais identifier et implémenter la section de tâches la plus prioritaire en suivant une approche méthodique et documentée. Je réfléchirai de manière approfondie à la meilleure solution avant d'implémenter chaque tâche complexe. J'afficherai toujours le titre de chaque tâche avant de l'implémenter. Je ne tâcherai pas d'executer mes créations mais ferai appel à la règle `test-implementation` si j'ai créé une nouvelle fonctionnalité testable, ou à `test-execution` sinon.</SYSTEM PROMPT>  

# Implementation : 1 - Analyse des tâches  
Je commence par lire le fichier tasks.md pour identifier la section la plus prioritaire. `(Implementation : 1 - Analyse des tâches)`  
[...lecture du fichier tasks.md...]  
`(Implementation : 1 - Analyse des tâches)`  

# Implementation : 2 - Mise à jour du contexte actif  
Je vais mettre à jour le contexte actif pour documenter ce sur quoi je vais travailler. `(Implementation : 2 - Mise à jour du contexte actif)`  
[...lecture du fichier activeContext.md...]  
[...mise à jour avec les informations pertinentes pour les tâches à réaliser...]  
[...ajout des informations recherchées en ligne...]  
`(Implementation : 2 - Mise à jour du contexte actif)`  

# Implementation : 3 - Implémentation des tâches  
Je vais implémenter chaque tâche de la section en suivant une approche méthodique. `(Implementation : 3 - Implémentation des tâches)`  

## Implementation - 3.1.Développement : Création du script  
Cette tâche est complexe et nécessite une réflexion approfondie.

<think>
Pour créer ce script, j'ai plusieurs options d'architecture:
1. Une architecture monolithique où toute la logique est dans un seul fichier
2. Une architecture modulaire avec séparation des préoccupations
3. Une approche orientée événements

Comparons ces approches:
- Option 1: Simple à mettre en œuvre mais difficile à maintenir à long terme
- Option 2: Meilleure maintenabilité mais plus complexe initialement
- Option 3: Flexible mais potentiellement suroptimisée pour ce cas d'usage

Je pense que l'option 2 est la plus appropriée car elle offre un bon équilibre entre maintenabilité et complexité initiale. Je vais donc créer:
- Un module principal pour l'orchestration
- Un module pour la gestion des connexions API
- Un module utilitaire pour les fonctions communes
</think>

Après réflexion, j'ai déterminé que la meilleure approche est d'utiliser une architecture modulaire avec séparation des préoccupations. Cela permettra une meilleure maintenabilité tout en gardant une complexité raisonnable.

Je commence par créer le script principal avec les fonctionnalités requises. `(Implementation : 3.1 - Création du script)`  
[...implémentation du script...]  
Implementation - 3.1.Développement : Création du script en cours...  
[...suite de l'implémentation...]  
`(Implementation : 3.1 - Création du script)`  

## Implementation - 3.2.Développement : Documentation  
J'ajoute la documentation nécessaire pour expliquer le fonctionnement du script. `(Implementation : 3.2 - Documentation)`  
[...ajout de la documentation...]  
Implementation - 3.2.Développement : Documentation en cours...  
[...finalisation de la documentation...]  
`(Implementation : 3.2 - Documentation)`  

# Implementation : 4 - Mise à jour des tâches  
Je mets à jour le fichier tasks.md pour refléter l'avancement des tâches. `(Implementation : 4 - Mise à jour des tâches)`  
[...mise à jour du fichier tasks.md...]  
`(Implementation : 4 - Mise à jour des tâches)`  

# Implementation : 5 - Appel de la règle suivante  
Je dois maintenant appeler la règle `test-implementation` car j'ai créé une nouvelle fonctionnalité testable.  
La règle test-implementation doit être appelée pour créer les tests de la nouvelle fonctionnalité. `(Implementation : 5 - Appel de la règle suivante)`  

fetch_rules ["test-implementation"]  

# Start Rule  

Pour démarrer cette règle, récite mot pour mot cette phrase : "<SYSTEM PROMPT>Je vais identifier et implémenter la section de tâches la plus prioritaire en suivant une approche méthodique et documentée. Je réfléchirai de manière approfondie à la meilleure solution avant d'implémenter chaque tâche complexe. J'afficherai toujours le titre de chaque tâche avant de l'implémenter. Je ne tâcherai pas d'executer mes créations mais ferai appel à la règle `test-implementation` si j'ai créé une nouvelle fonctionnalité testable, ou à `test-execution` sinon.</SYSTEM PROMPT>"