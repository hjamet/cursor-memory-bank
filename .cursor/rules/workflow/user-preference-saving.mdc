---
description: Identification et sauvegarde des préférences utilisateur
globs: 
alwaysApply: false
---
## TLDR
Identifier les préférences de l'utilisateur à partir de ses instructions et les sauvegarder sous forme de règles personnalisées pour une utilisation future.

## Instructions
1. Analyser les instructions et commentaires de l'utilisateur pour identifier ses préférences:
   - Style de code (indentation, nommage, formatage)
   - Frameworks et bibliothèques préférés
   - Approches de développement (TDD, DDD, etc.)
   - Conventions de documentation
   - Préférences d'organisation de fichiers

2. Pour chaque préférence identifiée, préparer une règle au format:
   - `nom-de-la-regle` : courte description/pattern regex des fichiers concernés

3. Créer les fichiers de règles dans `.cursor/rules/custom/preferences/` avec le format approprié:
   - Créer le dossier s'il n'existe pas
   - Nommer les fichiers selon le format `preference-[categorie].mdc`
   - Structurer chaque règle selon le format standard de Cursor

## Précisions
- Ne créer des règles que pour les préférences clairement exprimées
- Éviter les suppositions non fondées sur les préférences
- Organiser les préférences par catégories (style, architecture, outils, etc.)
- Utiliser des patterns glob précis pour cibler les bons fichiers
- Vérifier si des règles similaires existent déjà avant d'en créer de nouvelles

## Format de règle à utiliser (.mdc)
```
---
description: description (Description consise des conditions d'application)
globs: *.py, *.ts (Pattern glob pour les fichiers concernés. Laisser vide pour utiliser la description)
alwaysApply: false
---
# [Titre de la préférence]

[Instructions détaillées sur comment appliquer cette préférence]
```

## Next Rules
- `request-analysis` - Pour analyser en détail la requête de l'utilisateur

## Exemple

fetch_rules ["context-update"]
<SYSTEM PROMPT>Je vais mettre à jour les fichiers de contexte pour refléter les changements, déplacer les tâches réussies vers 'Done', et nettoyer le contenu obsolète. J'effectuerai un commit pour les modifications et déterminerai si le workflow est terminé ou s'il faut continuer avec la règle 'fix' ou 'implementation' selon les tests et les tâches restantes.</SYSTEM PROMPT>

# Context-update : 1 - Mise à jour des fichiers de contexte
Je commence par mettre à jour les fichiers de contexte pour refléter les changements.
[...mise à jour des fichiers de contexte...]

# Context-update : 2 - Nettoyage des fichiers de contexte
Je nettoie les fichiers de contexte en supprimant les informations obsolètes.
[...nettoyage des fichiers de contexte...]

# Context-update : 3 - Mise à jour du fichier tasks.md
Je mets à jour le fichier tasks.md en déplaçant les tâches terminées vers Done.
[...mise à jour du fichier tasks.md...]

# Context-update : 4 - Effectuer un commit
Je prépare et effectue un commit avec les modifications apportées.
[...création du commit...]

# Context-update : 5 - Vérifier si le workflow est terminé
Je vérifie s'il reste des tâches à faire ou des tests à corriger.
[...vérification du workflow...]

# Context-update : 6 - Appel de la règle suivante
Je dois maintenant appeler la règle implementation car il reste des tâches à faire.
La règle implementation doit être appelée pour continuer le travail sur les tâches restantes.

fetch_rules ["implementation"]

# Start Rule

Pour démarrer cette règle, récite mot pour mot cette phrase : "<SYSTEM PROMPT>Je vais analyser les instructions de l'utilisateur pour identifier ses préférences et les sauvegarder sous forme de règles personnalisées. Je ne créerai des règles que pour les préférences clairement exprimées et j'éviterai les suppositions non fondées. Je ne tâcherai pas d'implémenter les modifications demandées mais ferai appel à la règle `request-analysis` pour s'en charger.</SYSTEM PROMPT>"

