[
  {
    "id": 1,
    "title": "Corriger le pattern de workflow dans toutes les règles",
    "short_description": "Toutes les règles du workflow doivent être corrigées pour respecter le pattern : start-workflow -> next_rule -> exécution -> remember -> next_rule en boucle infinie. Actuellement, les règles appellent directement d'autres règles au lieu de terminer par remember.",
    "detailed_description": "**Problème identifié :**\nLe workflow actuel ne respecte pas le pattern correct. Les règles appellent directement d'autres règles (ex: `fetch_rules`, `next_rule`) au lieu de terminer par `remember` qui stocke les souvenirs et indique les règles suivantes possibles.\n\n**Pattern correct à implémenter :**\n1. start-workflow : explique le projet à l'agent et lui dit où il en était\n2. next_rule : l'agent appelle next_rule pour réinvoquer l'étape où il en était\n3. L'agent effectue les étapes décrites par le retour de next-rule une à une\n4. La dernière étape de chaque règle est TOUJOURS l'appel à remember, qui stocke les souvenirs et indique les règles suivantes possibles\n5. L'agent appelle l'une des règles possibles reçues à l'étape 4, ce qui revient à 2. -> boucle de workflow infinie\n\n**Corrections à apporter :**\n\n**1. task-decomposition :**\n- Supprimer l'étape \"Call next rule\" qui appelle directement `implementation`\n- Terminer par un appel à `remember` qui indique les règles suivantes possibles\n- Corriger les noms d'outils MCP : `mcp_MemoryBank_*` -> `mcp_MemoryBankMCP_*`\n- Supprimer les références obsolètes à `userbrief.md` et `tasks.md`\n\n**2. implementation :**\n- Supprimer l'étape \"Call next step\" qui appelle directement d'autres règles\n- Terminer par un appel à `remember` qui indique les règles suivantes possibles\n- Supprimer les références à `tasks.md` et `activeContext.md`\n- Supprimer la référence inexistante à `test-implementation`\n\n**3. fix :**\n- Supprimer l'étape \"Calling the next step\" qui appelle directement d'autres règles\n- Terminer par un appel à `remember` qui indique les règles suivantes possibles\n- Corriger les noms d'outils : `mcp_MyMCP_*` -> `mcp_ToolsMCP_*`\n- Supprimer les références à `tests.md`, `tasks.md`, `activeContext.md`\n- Supprimer les références inexistantes à `test-execution`\n\n**4. context-update :**\n- Supprimer l'étape \"Call the next step\" qui appelle directement d'autres règles\n- Terminer par un appel à `remember` qui indique les règles suivantes possibles\n- Supprimer les références à `userbrief.md`, `tasks.md`, `activeContext.md`\n\n**5. experience-execution :**\n- Supprimer l'étape \"Calling the next rule\" qui appelle directement d'autres règles\n- Terminer par un appel à `remember` qui indique les règles suivantes possibles\n- Corriger les noms d'outils : `mcp_MyMCP_*` -> `mcp_ToolsMCP_*`\n\n**6. start-workflow :**\n- Corriger l'affichage des objets mémoire pour qu'ils soient formatés lisiblement au lieu de `[object Object]`\n\n**Validation :**\n- Chaque règle doit se terminer par un appel à `remember`\n- Aucune règle ne doit appeler directement une autre règle\n- Tous les noms d'outils MCP doivent être corrects\n- Aucune référence à des fichiers obsolètes (tasks.md, userbrief.md, activeContext.md)\n- Aucune référence à des règles inexistantes (test-implementation, test-execution)",
    "dependencies": [],
    "status": "DONE",
    "impacted_files": [],
    "validation_criteria": "Tâche complétée avec succès : \n✅ Tous les fichiers de règles corrigés pour respecter le pattern start-workflow -> next_rule -> exécution -> remember -> next_rule\n✅ Toutes les références obsolètes aux fichiers .md supprimées et remplacées par les outils MCP\n✅ Tous les noms d'outils MCP corrigés (mcp_MemoryBank_* -> mcp_MemoryBankMCP_*, mcp_MyMCP_* -> mcp_ToolsMCP_*)\n✅ Toutes les règles se terminent maintenant par un appel à remember au lieu d'appels directs aux autres règles\n✅ Suppression des références inexistantes (test-implementation, test-execution)\n✅ Correction des template variables dans start-workflow.md pour éviter [object Object]",
    "created_date": "2025-06-22T21:58:47.988Z",
    "updated_date": "2025-06-22T22:04:09.965Z",
    "parent_id": null,
    "priority": 5
  },
  {
    "id": 2,
    "title": "Fix Streamlit interface to use userbrief.json instead of userbrief.md",
    "short_description": "L'interface Streamlit utilise encore l'ancien fichier userbrief.md au lieu du nouveau userbrief.json. Les nouvelles requêtes sont mal catégorisées comme archives au lieu d'être marquées \"à traiter\". Migration requise des requêtes existantes et correction complète de l'interface.",
    "detailed_description": "**PROBLÈME IDENTIFIÉ :**\nL'interface Streamlit (pages \"Add New Request\" et \"Memory Management\" tab \"Requêtes\") utilise encore l'ancien système de fichier userbrief.md au lieu du nouveau système userbrief.json basé sur les outils MCP.\n\n**TÂCHES À ACCOMPLIR :**\n\n1. **Migration des requêtes existantes :**\n   - Migrer les 2 requêtes du fichier userbrief.md vers userbrief.json avec le statut \"new\" (à traiter)\n   - Conserver l'historique et les métadonnées appropriées\n\n2. **Correction de add_request.py :**\n   - Remplacer la fonction add_request_to_userbrief() pour utiliser les outils MCP\n   - Utiliser mcp_MemoryBankMCP_update_userbrief pour ajouter les nouvelles requêtes\n   - S'assurer que les nouvelles requêtes ont le statut \"new\" au lieu d'être archivées\n   - Mettre à jour la fonction get_userbrief_status() pour lire depuis userbrief.json\n\n3. **Correction de memory.py :**\n   - Remplacer toutes les fonctions qui lisent/écrivent userbrief.md\n   - Utiliser les outils MCP pour la gestion des requêtes dans l'onglet \"Requêtes\"\n   - Mettre à jour l'affichage pour refléter le nouveau format JSON\n\n4. **Correction de app.py :**\n   - Mettre à jour get_userbrief_status() pour utiliser userbrief.json\n   - S'assurer que l'affichage des requêtes utilise le bon format\n\n5. **Suppression de l'ancien fichier :**\n   - Supprimer userbrief.md après migration complète\n   - Nettoyer toutes les références à l'ancien système\n\n**CRITÈRES D'ACCEPTATION :**\n- Les nouvelles requêtes ajoutées via Streamlit ont le statut \"new\" (à traiter)\n- L'interface affiche correctement les requêtes depuis userbrief.json\n- Les 2 requêtes existantes sont migrées avec le bon statut\n- L'ancien fichier userbrief.md est supprimé\n- Toutes les fonctionnalités de l'interface fonctionnent avec le nouveau système",
    "dependencies": [],
    "status": "DONE",
    "impacted_files": [
      ".cursor/streamlit_app/pages/add_request.py",
      ".cursor/streamlit_app/pages/memory.py",
      ".cursor/streamlit_app/app.py",
      ".cursor/memory-bank/userbrief.md",
      ".cursor/memory-bank/workflow/userbrief.json"
    ],
    "validation_criteria": "✅ TÂCHE TERMINÉE AVEC SUCCÈS - Toutes les étapes ont été accomplies : 1) Migration des 2 requêtes existantes de userbrief.md vers userbrief.json avec statut \"new\" (requêtes #4 et #5), 2) Correction complète de add_request.py pour utiliser les outils MCP et s'assurer que les nouvelles requêtes ont le statut \"new\" au lieu d'être archivées, 3) Correction de app.py pour lire depuis userbrief.json avec nouvelles métriques (Total, New, In Progress, Archived), 4) Correction complète de memory.py pour l'onglet \"Requêtes\" avec nouveau système JSON structuré, filtres par statut et informations détaillées, 5) Suppression de l'ancien fichier userbrief.md. L'interface Streamlit utilise maintenant exclusivement le système userbrief.json avec les outils MCP.",
    "created_date": "2025-06-23T07:48:01.613Z",
    "updated_date": "2025-06-23T07:53:29.233Z",
    "parent_id": null,
    "priority": 5
  },
  {
    "id": 3,
    "title": "Implement archive size limit for tasks and userbrief files",
    "short_description": "Limiter la taille des fichiers Task et userbrief à maximum 25 entrées archivées, en supprimant automatiquement les plus anciennes quand la limite est dépassée pour éviter des fichiers de taille infinie.",
    "detailed_description": "**OBJECTIF :**\nImplémenter un système de limitation automatique des entrées archivées dans les fichiers JSON de gestion des tâches et des requêtes utilisateur pour maintenir des fichiers de taille raisonnable.\n\n**SPÉCIFICATIONS TECHNIQUES :**\n\n1. **Limitation des tâches archivées (tasks.json) :**\n   - Maximum 25 tâches avec statut \"DONE\" conservées\n   - Quand une nouvelle tâche passe à \"DONE\" et que la limite est atteinte, supprimer la plus ancienne tâche \"DONE\"\n   - Conserver les tâches par ordre de date de mise à jour (updated_date) - garder les plus récentes\n   - Modifier le TaskManager dans `.cursor/mcp/memory-bank-mcp/lib/task_manager.js`\n\n2. **Limitation des requêtes archivées (userbrief.json) :**\n   - Maximum 25 requêtes avec statut \"archived\" conservées\n   - Quand une nouvelle requête passe à \"archived\" et que la limite est atteinte, supprimer la plus ancienne requête \"archived\"\n   - Conserver les requêtes par ordre de date de mise à jour (updated_at) - garder les plus récentes\n   - Modifier les fonctions dans `.cursor/mcp/memory-bank-mcp/lib/userbrief_manager.js`\n\n**IMPLÉMENTATION DÉTAILLÉE :**\n\n1. **TaskManager.updateTask() :**\n   - Ajouter une fonction `cleanupArchivedTasks()` appelée après chaque mise à jour de statut vers \"DONE\"\n   - Trier les tâches \"DONE\" par updated_date (desc) et garder seulement les 25 plus récentes\n   - Supprimer les tâches excédentaires du tableau et sauvegarder\n\n2. **UserBrief Manager :**\n   - Ajouter une fonction `cleanupArchivedRequests()` appelée dans `writeUserbriefData()`\n   - Trier les requêtes \"archived\" par updated_at (desc) et garder seulement les 25 plus récentes\n   - Supprimer les requêtes excédentaires du tableau et sauvegarder\n\n3. **Paramètres configurables :**\n   - Définir des constantes MAX_ARCHIVED_TASKS = 25 et MAX_ARCHIVED_REQUESTS = 25\n   - Permettre une configuration future si nécessaire\n\n**CRITÈRES D'ACCEPTATION :**\n- Les fichiers tasks.json et userbrief.json ne contiennent jamais plus de 25 entrées archivées\n- Les entrées les plus récentes sont conservées quand la limite est atteinte\n- Les entrées les plus anciennes sont automatiquement supprimées\n- Le système fonctionne de manière transparente sans intervention manuelle\n- Les tâches et requêtes non-archivées ne sont jamais supprimées (TODO, IN_PROGRESS, new, in_progress, etc.)\n\n**TESTS À EFFECTUER :**\n- Créer plus de 25 tâches et les marquer DONE pour tester la limitation\n- Créer plus de 25 requêtes et les archiver pour tester la limitation\n- Vérifier que les bonnes entrées sont conservées (les plus récentes)\n- Vérifier que les entrées non-archivées ne sont pas affectées",
    "dependencies": [],
    "status": "DONE",
    "impacted_files": [
      ".cursor/mcp/memory-bank-mcp/lib/task_manager.js",
      ".cursor/mcp/memory-bank-mcp/lib/userbrief_manager.js"
    ],
    "validation_criteria": "✅ TÂCHE TERMINÉE AVEC SUCCÈS - Implémentation complète de la limitation de taille des archives : 1) **TaskManager modifié** : Ajout de MAX_ARCHIVED_TASKS = 25, fonction cleanupArchivedTasks() qui trie par updated_date et garde les 25 plus récentes, appel automatique lors du passage au statut DONE. 2) **UserBrief Manager refactorisé** : Migration complète vers le système JSON (userbrief.json), ajout de MAX_ARCHIVED_REQUESTS = 25, fonction cleanupArchivedRequests() qui trie par updated_at et garde les 25 plus récentes, appel automatique dans writeUserbriefData(). 3) **Nouvelles fonctions** : updateUserbriefRequest() pour la gestion des mises à jour, correction du chemin vers .cursor/memory-bank/workflow/userbrief.json. 4) **Compatibilité** : Fonctions legacy conservées avec avertissements de dépréciation. Le système maintient maintenant automatiquement un maximum de 25 entrées archivées pour chaque fichier, supprimant les plus anciennes quand la limite est dépassée.",
    "created_date": "2025-06-23T07:55:52.530Z",
    "updated_date": "2025-06-23T08:00:36.944Z",
    "parent_id": null,
    "priority": 4
  },
  {
    "id": 4,
    "title": "Rewrite start.mdc rule in English with direct agent addressing",
    "short_description": "Réécrire la règle start.mdc en anglais en s'adressant directement à l'agent à la 2e personne (you) au lieu de la 3e personne (l'agent devrait), car c'est l'agent qui lit directement ce texte.",
    "detailed_description": "**OBJECTIF :**\nConvertir la règle start.mdc du français vers l'anglais et changer la perspective narrative pour s'adresser directement à l'agent qui lit le texte.\n\n**CHANGEMENTS REQUIS :**\n\n1. **Conversion linguistique :**\n   - Traduire tout le contenu du français vers l'anglais\n   - Maintenir la structure et le formatage markdown existant\n   - Conserver tous les éléments techniques (noms d'outils MCP, étapes du workflow, etc.)\n\n2. **Changement de perspective narrative :**\n   - **AVANT** (3e personne) : \\\"L'agent doit comprendre qu'il va entrer...\\\", \\\"L'agent appelle mcp_MemoryBankMCP_next_rule...\\\"\n   - **APRÈS** (2e personne) : \\\"You must understand that you will enter...\\\", \\\"You call mcp_MemoryBankMCP_next_rule...\\\"\n   - Remplacer toutes les références \\\"l'agent\\\" par \\\"you\\\"\n   - Utiliser l'impératif direct : \\\"Call the tool\\\", \\\"Follow these steps\\\", \\\"Remember that you must...\\\"\n\n3. **Amélioration de la clarté :**\n   - Rendre les instructions plus directes et actionables\n   - Utiliser un ton instructionnel clair (\\\"You must\\\", \\\"You should\\\", \\\"You will\\\")\n   - Maintenir l'emphase sur les règles critiques avec des sections bien marquées\n\n**STRUCTURE À CONSERVER :**\n- Titre et objectif\n- Fonctionnement du workflow autonome avec diagramme\n- Étapes détaillées du workflow (1. INITIALISATION, 2. BOUCLE INFINIE, etc.)\n- Liste des étapes disponibles (start-workflow, task-decomposition, etc.)\n- Règles critiques pour l'agent\n- Outils MCP disponibles\n- Priorités de l'agent\n- Section de démarrage immédiat\n\n**ÉLÉMENTS TECHNIQUES À PRÉSERVER :**\n- Tous les noms d'outils MCP (mcp_MemoryBankMCP_*, mcp_ToolsMCP_*)\n- Noms des étapes de workflow (start-workflow, task-decomposition, implementation, fix, context-update, experience-execution)\n- Structure du pattern de boucle infinie\n- Statuts des tâches et requêtes (TODO, IN_PROGRESS, DONE, new, archived, etc.)\n\n**CRITÈRES D'ACCEPTATION :**\n- Le fichier .cursor/rules/start.mdc est entièrement en anglais\n- Toutes les instructions utilisent la 2e personne (you) au lieu de la 3e personne\n- Le contenu technique est préservé (noms d'outils, étapes, statuts)\n- La structure markdown et le formatage sont maintenus\n- Les règles critiques restent clairement identifiées et mises en évidence\n- Le ton est direct et instructionnel pour l'agent qui lit le texte\n\n**VALIDATION :**\n- L'agent peut lire et comprendre directement les instructions en anglais\n- Les instructions sont claires et actionables avec la perspective \\\"you\\\"\n- Aucune information technique n'est perdue dans la traduction",
    "dependencies": [],
    "status": "DONE",
    "impacted_files": [
      ".cursor/rules/start.mdc"
    ],
    "validation_criteria": "✅ TÂCHE TERMINÉE AVEC SUCCÈS - La règle start.mdc a été complètement réécrite en anglais avec adressage direct à l'agent (2e personne). Tous les critères d'acceptation sont remplis : 1) Fichier entièrement en anglais, 2) Utilisation systématique de la 2e personne (you/your) au lieu de la 3e personne (l'agent), 3) Préservation de tous les éléments techniques (noms d'outils MCP, étapes workflow, statuts), 4) Maintien de la structure markdown existante, 5) Règles critiques clairement identifiées et mises en évidence, 6) Ton direct et instructionnel pour l'agent. L'agent peut maintenant lire directement les instructions en anglais avec des commandes claires et actionables.",
    "created_date": "2025-06-23T07:56:18.891Z",
    "updated_date": "2025-06-23T07:58:41.228Z",
    "parent_id": null,
    "priority": 3
  },
  {
    "id": 5,
    "title": "Investigate and fix update_userbrief MCP tool error",
    "short_description": "Diagnose and resolve the \"fs.readFileSync is not a function\" error in the update_userbrief MCP tool that prevents proper userbrief management.",
    "detailed_description": "**Problem Analysis:**\nThe update_userbrief MCP tool is failing with \"fs.readFileSync is not a function\" error, preventing proper userbrief management through the MCP interface.\n\n**Root Cause Investigation Required:**\n1. Check ES6 import issues in userbrief_manager.js (likely already fixed based on recent commits)\n2. Verify MCP server restart status and cache issues\n3. Test direct functionality vs MCP tool interface\n4. Identify any remaining module compatibility issues\n\n**Implementation Steps:**\n1. Restart MCP server to ensure latest ES6 fixes are loaded\n2. Test update_userbrief tool directly via MCP interface\n3. Debug any remaining import or module issues\n4. Verify all userbrief operations work correctly\n5. Test end-to-end functionality with Streamlit interface\n\n**Acceptance Criteria:**\n- update_userbrief MCP tool works without errors\n- Can successfully mark requests as archived, in_progress, or add comments\n- Streamlit interface can interact with userbrief via MCP tools\n- All ES6 import issues resolved\n- MCP server runs stably without module errors\n\n**Technical Notes:**\n- Recent commits show ES6 fixes were implemented in userbrief_manager.js\n- Problem may be server restart/cache related rather than code issue\n- Need to verify MCP server is using latest code version",
    "dependencies": [],
    "status": "DONE",
    "impacted_files": [
      ".cursor/mcp/memory-bank-mcp/lib/userbrief_manager.js",
      ".cursor/mcp/memory-bank-mcp/mcp_tools/update_userbrief.js",
      ".cursor/mcp/memory-bank-mcp/server.js"
    ],
    "validation_criteria": "Task completed when: (1) update_userbrief MCP tool executes without errors, (2) Can mark requests as archived/in_progress via MCP, (3) Streamlit interface works with MCP tools, (4) MCP server runs stably, (5) All userbrief operations tested and functional",
    "created_date": "2025-06-23T08:06:59.606Z",
    "updated_date": "2025-06-23T09:00:53.495Z",
    "parent_id": null,
    "priority": 5
  },
  {
    "id": 6,
    "title": "Enhance get_next_tasks selection algorithm with dependency graph analysis",
    "short_description": "Improve the get_next_tasks function to automatically identify the most urgent available tasks using dependency graph analysis and priority weighting, with intelligent tie-breaking.",
    "detailed_description": "**Current Problem:**\nThe get_next_tasks function has suboptimal task selection logic that doesn't effectively analyze the dependency graph and priority system to identify the most urgent tasks automatically.\n\n**Requirements:**\n1. **Dependency Graph Analysis**: Implement proper topological analysis to identify tasks whose dependencies are fully satisfied\n2. **Priority Weighting**: Use task priorities (1-5 scale) as primary selection criteria\n3. **Intelligent Selection**: Automatically determine the single most urgent task or group of equal-priority tasks\n4. **Tie-Breaking Logic**: When multiple tasks have equal priority and no dependencies, return all of them with explanation\n5. **Clear Communication**: Explain to the agent why specific tasks were selected and provide decision rationale\n\n**Implementation Approach:**\n1. Create dependency graph analysis function to validate all dependencies are DONE\n2. Implement priority-based sorting with dependency-readiness filtering\n3. Add tie-breaking logic for equal-priority tasks\n4. Enhance response format to include selection rationale\n5. Add comprehensive logging for debugging task selection decisions\n\n**Enhanced Response Format:**\n- Most urgent available task(s) with rationale\n- Dependency status for each returned task\n- Priority level explanation\n- Selection strategy used (single highest priority vs multiple equal priority)\n- Clear guidance for agent on which task(s) to tackle\n\n**Acceptance Criteria:**\n- Function automatically identifies highest priority available tasks\n- Properly validates all dependencies are completed before marking tasks available\n- Returns multiple tasks only when they have equal priority and no blocking dependencies\n- Provides clear rationale for task selection decisions\n- Handles edge cases (no available tasks, circular dependencies, etc.)\n- Performance optimized for large task sets\n\n**Technical Implementation:**\n- Modify get_next_tasks.js with enhanced algorithm\n- Add dependency graph validation utilities\n- Implement priority-based task ranking system\n- Add comprehensive response formatting\n- Include detailed logging and error handling",
    "dependencies": [],
    "status": "DONE",
    "impacted_files": [
      ".cursor/mcp/memory-bank-mcp/mcp_tools/get_next_tasks.js",
      ".cursor/mcp/memory-bank-mcp/lib/task_manager.js"
    ],
    "validation_criteria": "Task completed when: (1) get_next_tasks automatically identifies most urgent tasks using dependency+priority analysis, (2) Returns single task or group of equal-priority tasks with rationale, (3) Properly validates dependencies before marking tasks available, (4) Provides clear selection explanation to agent, (5) Handles all edge cases gracefully, (6) Performance tested with large task sets",
    "created_date": "2025-06-23T08:07:13.875Z",
    "updated_date": "2025-06-23T09:00:59.348Z",
    "parent_id": null,
    "priority": 4
  },
  {
    "id": 7,
    "title": "Clear text area after successful request submission in Streamlit",
    "short_description": "Modify the Streamlit add_request interface to automatically clear the text area after successful request submission for better user experience.",
    "detailed_description": "**User Experience Issue:**\nCurrently, when users submit a request via the Streamlit \"Add New Request\" page, the text area retains the submitted content, requiring manual deletion for the next request.\n\n**Desired Behavior:**\nAfter successful request submission, the text area should automatically clear, providing immediate visual feedback that the request was processed and preparing the interface for the next request.\n\n**Technical Challenge:**\nStreamlit's form-based approach makes text clearing non-trivial. The text area is controlled by Streamlit's session state and form submission mechanics.\n\n**Implementation Approaches:**\n1. **Session State Management**: Use st.session_state to control text area value and reset after successful submission\n2. **Form Key Rotation**: Change form key after submission to force form reset\n3. **JavaScript Integration**: Use Streamlit components with JavaScript for direct DOM manipulation\n4. **Rerun with State Reset**: Trigger st.rerun() with cleared session state\n\n**Recommended Solution:**\nImplement session state management approach:\n1. Store text area content in st.session_state\n2. On successful submission, clear the session state variable\n3. Use st.rerun() to refresh the interface with cleared text\n4. Maintain all other functionality (success messages, metrics, etc.)\n\n**Files to Modify:**\n- `.cursor/streamlit_app/pages/add_request.py`: Main implementation\n- Potentially add session state management utilities\n\n**Acceptance Criteria:**\n- Text area clears automatically after successful request submission\n- Success message still displays properly\n- All other functionality remains intact (metrics, validation, error handling)\n- User experience feels smooth and responsive\n- No side effects on other Streamlit pages\n\n**Technical Notes:**\n- Test with different Streamlit versions for compatibility\n- Ensure clearing works with both successful and failed submissions appropriately\n- Maintain form validation behavior\n- Consider accessibility implications",
    "dependencies": [],
    "status": "DONE",
    "impacted_files": [
      ".cursor/streamlit_app/pages/add_request.py"
    ],
    "validation_criteria": "Task completed when: (1) Text area automatically clears after successful request submission, (2) Success/error messages display correctly, (3) All form validation works as before, (4) User can immediately type new request without manual clearing, (5) No negative impact on other Streamlit functionality, (6) Solution tested with multiple consecutive submissions",
    "created_date": "2025-06-23T08:07:27.614Z",
    "updated_date": "2025-06-23T09:01:31.952Z",
    "parent_id": null,
    "priority": 2
  },
  {
    "id": 8,
    "title": "Implement archive size limitation for tasks and userbrief files",
    "short_description": "Limit the archive size of tasks.json and userbrief.json to maximum 25 archived entries, automatically removing oldest entries when limit is exceeded to prevent infinite file growth.",
    "detailed_description": "**Problem:**\nThe tasks.json and userbrief.json files can grow infinitely as archived entries accumulate, potentially causing performance issues and making the files unwieldy.\n\n**Requirements:**\n1. **Archive Size Limit**: Cap archived entries at 25 maximum for both files\n2. **Automatic Cleanup**: When limit is exceeded, remove oldest archived entries\n3. **Retention Strategy**: Keep only the most recent 25 archived entries\n4. **Non-Intrusive**: Only affect archived entries, never touch active/new/in-progress items\n5. **Consistent Implementation**: Apply same logic to both task and userbrief management\n\n**Implementation Approach:**\n1. **Task Manager Enhancement**: Modify task archival process to check archive count\n2. **Userbrief Manager Enhancement**: Modify userbrief archival process similarly  \n3. **Cleanup Function**: Create utility to remove excess archived entries by date\n4. **Automatic Triggering**: Run cleanup automatically when archiving new entries\n5. **Preservation Logic**: Always preserve the 25 most recent archived entries\n\n**Technical Implementation:**\n- Modify `task_manager.js` to add archive size checking\n- Modify `userbrief_manager.js` to add archive size checking  \n- Create `cleanup_archives()` function for both managers\n- Sort archived entries by date and keep only newest 25\n- Trigger cleanup automatically in `update_task()` and `update_userbrief()` when status changes to archived\n\n**Files to Modify:**\n- `.cursor/mcp/memory-bank-mcp/lib/task_manager.js`\n- `.cursor/mcp/memory-bank-mcp/lib/userbrief_manager.js`\n\n**Acceptance Criteria:**\n- Archives never exceed 25 entries for both tasks and userbrief\n- Oldest entries are automatically removed when limit is reached\n- Active/new/in-progress entries are never affected by cleanup\n- Cleanup happens transparently during normal archival operations\n- Performance remains good even with frequent archival operations\n- No data loss for recent archived entries\n\n**Testing Requirements:**\n- Test with exactly 25 archived entries (no cleanup)\n- Test with 26+ archived entries (cleanup triggered)\n- Verify oldest entries are removed correctly\n- Ensure active entries are never touched\n- Test both task and userbrief cleanup independently",
    "dependencies": [],
    "status": "TODO",
    "impacted_files": [
      "/.cursor/mcp/memory-bank-mcp/lib/task_manager.js",
      "/.cursor/mcp/memory-bank-mcp/lib/userbrief_manager.js"
    ],
    "validation_criteria": "Task completed when: (1) Both task and userbrief archives are capped at 25 entries maximum, (2) Automatic cleanup removes oldest entries when limit exceeded, (3) Active/new/in-progress entries never affected, (4) Cleanup triggers automatically during archival operations, (5) All functionality tested with various archive sizes, (6) Performance remains optimal",
    "created_date": "2025-06-23T09:02:06.659Z",
    "updated_date": "2025-06-23T09:02:06.659Z",
    "parent_id": null,
    "priority": 3
  }
]