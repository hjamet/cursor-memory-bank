[
  {
    "id": 1,
    "title": "Corriger le pattern de workflow dans toutes les règles",
    "short_description": "Toutes les règles du workflow doivent être corrigées pour respecter le pattern : start-workflow -> next_rule -> exécution -> remember -> next_rule en boucle infinie. Actuellement, les règles appellent directement d'autres règles au lieu de terminer par remember.",
    "detailed_description": "**Problème identifié :**\nLe workflow actuel ne respecte pas le pattern correct. Les règles appellent directement d'autres règles (ex: `fetch_rules`, `next_rule`) au lieu de terminer par `remember` qui stocke les souvenirs et indique les règles suivantes possibles.\n\n**Pattern correct à implémenter :**\n1. start-workflow : explique le projet à l'agent et lui dit où il en était\n2. next_rule : l'agent appelle next_rule pour réinvoquer l'étape où il en était\n3. L'agent effectue les étapes décrites par le retour de next-rule une à une\n4. La dernière étape de chaque règle est TOUJOURS l'appel à remember, qui stocke les souvenirs et indique les règles suivantes possibles\n5. L'agent appelle l'une des règles possibles reçues à l'étape 4, ce qui revient à 2. -> boucle de workflow infinie\n\n**Corrections à apporter :**\n\n**1. task-decomposition :**\n- Supprimer l'étape \"Call next rule\" qui appelle directement `implementation`\n- Terminer par un appel à `remember` qui indique les règles suivantes possibles\n- Corriger les noms d'outils MCP : `mcp_MemoryBank_*` -> `mcp_MemoryBankMCP_*`\n- Supprimer les références obsolètes à `userbrief.md` et `tasks.md`\n\n**2. implementation :**\n- Supprimer l'étape \"Call next step\" qui appelle directement d'autres règles\n- Terminer par un appel à `remember` qui indique les règles suivantes possibles\n- Supprimer les références à `tasks.md` et `activeContext.md`\n- Supprimer la référence inexistante à `test-implementation`\n\n**3. fix :**\n- Supprimer l'étape \"Calling the next step\" qui appelle directement d'autres règles\n- Terminer par un appel à `remember` qui indique les règles suivantes possibles\n- Corriger les noms d'outils : `mcp_MyMCP_*` -> `mcp_ToolsMCP_*`\n- Supprimer les références à `tests.md`, `tasks.md`, `activeContext.md`\n- Supprimer les références inexistantes à `test-execution`\n\n**4. context-update :**\n- Supprimer l'étape \"Call the next step\" qui appelle directement d'autres règles\n- Terminer par un appel à `remember` qui indique les règles suivantes possibles\n- Supprimer les références à `userbrief.md`, `tasks.md`, `activeContext.md`\n\n**5. experience-execution :**\n- Supprimer l'étape \"Calling the next rule\" qui appelle directement d'autres règles\n- Terminer par un appel à `remember` qui indique les règles suivantes possibles\n- Corriger les noms d'outils : `mcp_MyMCP_*` -> `mcp_ToolsMCP_*`\n\n**6. start-workflow :**\n- Corriger l'affichage des objets mémoire pour qu'ils soient formatés lisiblement au lieu de `[object Object]`\n\n**Validation :**\n- Chaque règle doit se terminer par un appel à `remember`\n- Aucune règle ne doit appeler directement une autre règle\n- Tous les noms d'outils MCP doivent être corrects\n- Aucune référence à des fichiers obsolètes (tasks.md, userbrief.md, activeContext.md)\n- Aucune référence à des règles inexistantes (test-implementation, test-execution)",
    "dependencies": [],
    "status": "DONE",
    "impacted_files": [],
    "validation_criteria": "Tâche complétée avec succès : \n✅ Tous les fichiers de règles corrigés pour respecter le pattern start-workflow -> next_rule -> exécution -> remember -> next_rule\n✅ Toutes les références obsolètes aux fichiers .md supprimées et remplacées par les outils MCP\n✅ Tous les noms d'outils MCP corrigés (mcp_MemoryBank_* -> mcp_MemoryBankMCP_*, mcp_MyMCP_* -> mcp_ToolsMCP_*)\n✅ Toutes les règles se terminent maintenant par un appel à remember au lieu d'appels directs aux autres règles\n✅ Suppression des références inexistantes (test-implementation, test-execution)\n✅ Correction des template variables dans start-workflow.md pour éviter [object Object]",
    "created_date": "2025-06-22T21:58:47.988Z",
    "updated_date": "2025-06-22T22:04:09.965Z",
    "parent_id": null,
    "priority": 5
  },
  {
    "id": 2,
    "title": "Fix Streamlit interface to use userbrief.json instead of userbrief.md",
    "short_description": "L'interface Streamlit utilise encore l'ancien fichier userbrief.md au lieu du nouveau userbrief.json. Les nouvelles requêtes sont mal catégorisées comme archives au lieu d'être marquées \"à traiter\". Migration requise des requêtes existantes et correction complète de l'interface.",
    "detailed_description": "**PROBLÈME IDENTIFIÉ :**\nL'interface Streamlit (pages \"Add New Request\" et \"Memory Management\" tab \"Requêtes\") utilise encore l'ancien système de fichier userbrief.md au lieu du nouveau système userbrief.json basé sur les outils MCP.\n\n**TÂCHES À ACCOMPLIR :**\n\n1. **Migration des requêtes existantes :**\n   - Migrer les 2 requêtes du fichier userbrief.md vers userbrief.json avec le statut \"new\" (à traiter)\n   - Conserver l'historique et les métadonnées appropriées\n\n2. **Correction de add_request.py :**\n   - Remplacer la fonction add_request_to_userbrief() pour utiliser les outils MCP\n   - Utiliser mcp_MemoryBankMCP_update_userbrief pour ajouter les nouvelles requêtes\n   - S'assurer que les nouvelles requêtes ont le statut \"new\" au lieu d'être archivées\n   - Mettre à jour la fonction get_userbrief_status() pour lire depuis userbrief.json\n\n3. **Correction de memory.py :**\n   - Remplacer toutes les fonctions qui lisent/écrivent userbrief.md\n   - Utiliser les outils MCP pour la gestion des requêtes dans l'onglet \"Requêtes\"\n   - Mettre à jour l'affichage pour refléter le nouveau format JSON\n\n4. **Correction de app.py :**\n   - Mettre à jour get_userbrief_status() pour utiliser userbrief.json\n   - S'assurer que l'affichage des requêtes utilise le bon format\n\n5. **Suppression de l'ancien fichier :**\n   - Supprimer userbrief.md après migration complète\n   - Nettoyer toutes les références à l'ancien système\n\n**CRITÈRES D'ACCEPTATION :**\n- Les nouvelles requêtes ajoutées via Streamlit ont le statut \"new\" (à traiter)\n- L'interface affiche correctement les requêtes depuis userbrief.json\n- Les 2 requêtes existantes sont migrées avec le bon statut\n- L'ancien fichier userbrief.md est supprimé\n- Toutes les fonctionnalités de l'interface fonctionnent avec le nouveau système",
    "dependencies": [],
    "status": "DONE",
    "impacted_files": [
      ".cursor/streamlit_app/pages/add_request.py",
      ".cursor/streamlit_app/pages/memory.py",
      ".cursor/streamlit_app/app.py",
      ".cursor/memory-bank/userbrief.md",
      ".cursor/memory-bank/workflow/userbrief.json"
    ],
    "validation_criteria": "✅ TÂCHE TERMINÉE AVEC SUCCÈS - Toutes les étapes ont été accomplies : 1) Migration des 2 requêtes existantes de userbrief.md vers userbrief.json avec statut \"new\" (requêtes #4 et #5), 2) Correction complète de add_request.py pour utiliser les outils MCP et s'assurer que les nouvelles requêtes ont le statut \"new\" au lieu d'être archivées, 3) Correction de app.py pour lire depuis userbrief.json avec nouvelles métriques (Total, New, In Progress, Archived), 4) Correction complète de memory.py pour l'onglet \"Requêtes\" avec nouveau système JSON structuré, filtres par statut et informations détaillées, 5) Suppression de l'ancien fichier userbrief.md. L'interface Streamlit utilise maintenant exclusivement le système userbrief.json avec les outils MCP.",
    "created_date": "2025-06-23T07:48:01.613Z",
    "updated_date": "2025-06-23T07:53:29.233Z",
    "parent_id": null,
    "priority": 5
  },
  {
    "id": 3,
    "title": "Implement archive size limit for tasks and userbrief files",
    "short_description": "Limiter la taille des fichiers Task et userbrief à maximum 25 entrées archivées, en supprimant automatiquement les plus anciennes quand la limite est dépassée pour éviter des fichiers de taille infinie.",
    "detailed_description": "**OBJECTIF :**\nImplémenter un système de limitation automatique des entrées archivées dans les fichiers JSON de gestion des tâches et des requêtes utilisateur pour maintenir des fichiers de taille raisonnable.\n\n**SPÉCIFICATIONS TECHNIQUES :**\n\n1. **Limitation des tâches archivées (tasks.json) :**\n   - Maximum 25 tâches avec statut \"DONE\" conservées\n   - Quand une nouvelle tâche passe à \"DONE\" et que la limite est atteinte, supprimer la plus ancienne tâche \"DONE\"\n   - Conserver les tâches par ordre de date de mise à jour (updated_date) - garder les plus récentes\n   - Modifier le TaskManager dans `.cursor/mcp/memory-bank-mcp/lib/task_manager.js`\n\n2. **Limitation des requêtes archivées (userbrief.json) :**\n   - Maximum 25 requêtes avec statut \"archived\" conservées\n   - Quand une nouvelle requête passe à \"archived\" et que la limite est atteinte, supprimer la plus ancienne requête \"archived\"\n   - Conserver les requêtes par ordre de date de mise à jour (updated_at) - garder les plus récentes\n   - Modifier les fonctions dans `.cursor/mcp/memory-bank-mcp/lib/userbrief_manager.js`\n\n**IMPLÉMENTATION DÉTAILLÉE :**\n\n1. **TaskManager.updateTask() :**\n   - Ajouter une fonction `cleanupArchivedTasks()` appelée après chaque mise à jour de statut vers \"DONE\"\n   - Trier les tâches \"DONE\" par updated_date (desc) et garder seulement les 25 plus récentes\n   - Supprimer les tâches excédentaires du tableau et sauvegarder\n\n2. **UserBrief Manager :**\n   - Ajouter une fonction `cleanupArchivedRequests()` appelée dans `writeUserbriefData()`\n   - Trier les requêtes \"archived\" par updated_at (desc) et garder seulement les 25 plus récentes\n   - Supprimer les requêtes excédentaires du tableau et sauvegarder\n\n3. **Paramètres configurables :**\n   - Définir des constantes MAX_ARCHIVED_TASKS = 25 et MAX_ARCHIVED_REQUESTS = 25\n   - Permettre une configuration future si nécessaire\n\n**CRITÈRES D'ACCEPTATION :**\n- Les fichiers tasks.json et userbrief.json ne contiennent jamais plus de 25 entrées archivées\n- Les entrées les plus récentes sont conservées quand la limite est atteinte\n- Les entrées les plus anciennes sont automatiquement supprimées\n- Le système fonctionne de manière transparente sans intervention manuelle\n- Les tâches et requêtes non-archivées ne sont jamais supprimées (TODO, IN_PROGRESS, new, in_progress, etc.)\n\n**TESTS À EFFECTUER :**\n- Créer plus de 25 tâches et les marquer DONE pour tester la limitation\n- Créer plus de 25 requêtes et les archiver pour tester la limitation\n- Vérifier que les bonnes entrées sont conservées (les plus récentes)\n- Vérifier que les entrées non-archivées ne sont pas affectées",
    "dependencies": [],
    "status": "DONE",
    "impacted_files": [
      ".cursor/mcp/memory-bank-mcp/lib/task_manager.js",
      ".cursor/mcp/memory-bank-mcp/lib/userbrief_manager.js"
    ],
    "validation_criteria": "✅ TÂCHE TERMINÉE AVEC SUCCÈS - Implémentation complète de la limitation de taille des archives : 1) **TaskManager modifié** : Ajout de MAX_ARCHIVED_TASKS = 25, fonction cleanupArchivedTasks() qui trie par updated_date et garde les 25 plus récentes, appel automatique lors du passage au statut DONE. 2) **UserBrief Manager refactorisé** : Migration complète vers le système JSON (userbrief.json), ajout de MAX_ARCHIVED_REQUESTS = 25, fonction cleanupArchivedRequests() qui trie par updated_at et garde les 25 plus récentes, appel automatique dans writeUserbriefData(). 3) **Nouvelles fonctions** : updateUserbriefRequest() pour la gestion des mises à jour, correction du chemin vers .cursor/memory-bank/workflow/userbrief.json. 4) **Compatibilité** : Fonctions legacy conservées avec avertissements de dépréciation. Le système maintient maintenant automatiquement un maximum de 25 entrées archivées pour chaque fichier, supprimant les plus anciennes quand la limite est dépassée.",
    "created_date": "2025-06-23T07:55:52.530Z",
    "updated_date": "2025-06-23T08:00:36.944Z",
    "parent_id": null,
    "priority": 4
  },
  {
    "id": 4,
    "title": "Rewrite start.mdc rule in English with direct agent addressing",
    "short_description": "Réécrire la règle start.mdc en anglais en s'adressant directement à l'agent à la 2e personne (you) au lieu de la 3e personne (l'agent devrait), car c'est l'agent qui lit directement ce texte.",
    "detailed_description": "**OBJECTIF :**\nConvertir la règle start.mdc du français vers l'anglais et changer la perspective narrative pour s'adresser directement à l'agent qui lit le texte.\n\n**CHANGEMENTS REQUIS :**\n\n1. **Conversion linguistique :**\n   - Traduire tout le contenu du français vers l'anglais\n   - Maintenir la structure et le formatage markdown existant\n   - Conserver tous les éléments techniques (noms d'outils MCP, étapes du workflow, etc.)\n\n2. **Changement de perspective narrative :**\n   - **AVANT** (3e personne) : \\\"L'agent doit comprendre qu'il va entrer...\\\", \\\"L'agent appelle mcp_MemoryBankMCP_next_rule...\\\"\n   - **APRÈS** (2e personne) : \\\"You must understand that you will enter...\\\", \\\"You call mcp_MemoryBankMCP_next_rule...\\\"\n   - Remplacer toutes les références \\\"l'agent\\\" par \\\"you\\\"\n   - Utiliser l'impératif direct : \\\"Call the tool\\\", \\\"Follow these steps\\\", \\\"Remember that you must...\\\"\n\n3. **Amélioration de la clarté :**\n   - Rendre les instructions plus directes et actionables\n   - Utiliser un ton instructionnel clair (\\\"You must\\\", \\\"You should\\\", \\\"You will\\\")\n   - Maintenir l'emphase sur les règles critiques avec des sections bien marquées\n\n**STRUCTURE À CONSERVER :**\n- Titre et objectif\n- Fonctionnement du workflow autonome avec diagramme\n- Étapes détaillées du workflow (1. INITIALISATION, 2. BOUCLE INFINIE, etc.)\n- Liste des étapes disponibles (start-workflow, task-decomposition, etc.)\n- Règles critiques pour l'agent\n- Outils MCP disponibles\n- Priorités de l'agent\n- Section de démarrage immédiat\n\n**ÉLÉMENTS TECHNIQUES À PRÉSERVER :**\n- Tous les noms d'outils MCP (mcp_MemoryBankMCP_*, mcp_ToolsMCP_*)\n- Noms des étapes de workflow (start-workflow, task-decomposition, implementation, fix, context-update, experience-execution)\n- Structure du pattern de boucle infinie\n- Statuts des tâches et requêtes (TODO, IN_PROGRESS, DONE, new, archived, etc.)\n\n**CRITÈRES D'ACCEPTATION :**\n- Le fichier .cursor/rules/start.mdc est entièrement en anglais\n- Toutes les instructions utilisent la 2e personne (you) au lieu de la 3e personne\n- Le contenu technique est préservé (noms d'outils, étapes, statuts)\n- La structure markdown et le formatage sont maintenus\n- Les règles critiques restent clairement identifiées et mises en évidence\n- Le ton est direct et instructionnel pour l'agent qui lit le texte\n\n**VALIDATION :**\n- L'agent peut lire et comprendre directement les instructions en anglais\n- Les instructions sont claires et actionables avec la perspective \\\"you\\\"\n- Aucune information technique n'est perdue dans la traduction",
    "dependencies": [],
    "status": "DONE",
    "impacted_files": [
      ".cursor/rules/start.mdc"
    ],
    "validation_criteria": "✅ TÂCHE TERMINÉE AVEC SUCCÈS - La règle start.mdc a été complètement réécrite en anglais avec adressage direct à l'agent (2e personne). Tous les critères d'acceptation sont remplis : 1) Fichier entièrement en anglais, 2) Utilisation systématique de la 2e personne (you/your) au lieu de la 3e personne (l'agent), 3) Préservation de tous les éléments techniques (noms d'outils MCP, étapes workflow, statuts), 4) Maintien de la structure markdown existante, 5) Règles critiques clairement identifiées et mises en évidence, 6) Ton direct et instructionnel pour l'agent. L'agent peut maintenant lire directement les instructions en anglais avec des commandes claires et actionables.",
    "created_date": "2025-06-23T07:56:18.891Z",
    "updated_date": "2025-06-23T07:58:41.228Z",
    "parent_id": null,
    "priority": 3
  }
]